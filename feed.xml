<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>养恐龙</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://leay.net/"/>
  <updated>2022-09-02T18:40:22.596Z</updated>
  <id>https://leay.net/</id>
  
  <author>
    <name>hqweay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「上下文」</title>
    <link href="https://leay.net/2022/09/03/midorimidori/"/>
    <id>https://leay.net/2022/09/03/midorimidori/</id>
    <published>2022-09-02T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绿子"><a class="markdownIt-Anchor" href="#绿子"></a> 绿子</h2><p>「可爱极了！」</p><p>「绿子，」她说，「要加上名宇。」</p><p>「可爱极了，绿子。」我补充道。</p><p>「极了是怎么个程度？」</p><p>「山崩海枯那样可爱。」</p><hr><p>「最最喜欢你，绿子。」</p><p>「什么程度？」</p><p>「像喜欢春天的熊一样。」</p><p>「春天的熊？」绿子再次扬起脸，「什么春天的熊？」</p><p>「春天的原野里，你，个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：『你好，小姐，和我一块儿打滚玩好么？』接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？」</p><p>「太棒了。」</p><p>「我就这么喜欢你。」</p><hr><p>「喂，喂喂，说点什么呀！」绿子把脸埋在我胸前说。</p><p>「说什么？」</p><p>「什么都行，只要我听着心里舒坦。」</p><p>「可爱极了！」</p><p>「绿子，」她说，「要加上名宇。」</p><p>「可爱极了，绿子。」我补充道。</p><p>「极了是怎么个程度？」</p><p>「山崩海枯那样可爱。」</p><p>绿子扬脸看看我：「你用词倒还不同凡响。」</p><p>「给你这么一说，我心里也暖融融的。」我笑道。</p><p>「来句更棒的。」</p><p>「最最喜欢你，绿子。」</p><p>「什么程度？」</p><p>「像喜欢春天的熊一样。」</p><p>「春天的熊？」绿子再次扬起脸，「什么春天的熊？」</p><p>「春天的原野里，你，个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说道：『你好，小姐，和我一块儿打滚玩好么？』接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？」</p><p>「太棒了。」</p><p>「我就这么喜欢你。」</p><p>绿子紧紧贴住我的胸口，「好上天了！」绿子说，「既然这么喜欢，我，我说什么你都肯听？不生气？」</p><p>「当然」</p><p>「那么，你能永远不嫌弃我？」</p><p>「那还用说。」说着，我抚摸她像小男孩那般又短又软的头发。「不要紧，放心，一切都会一帆风顺。」</p><p>「可我就是怕。」绿子说。</p><hr><p>「喜欢我的发型？」</p><p>「好得不得了。」</p><p>「如何好法？」</p><p>「好得全世界森林里的树统统倒在地上。」</p><p>「真那样想？」</p><p>「真那样想。」</p><p>「喜欢我喜欢到什么程度？」绿子问。</p><p>「整个世界森林里的老虎全都溶化成黄油。」</p><hr><p>想为你做一道菜，但是我没有锅子。</p><p>想为你编一条围巾，但是我没有毛线。</p><p>想为你写一首诗，但是我没有笔。</p><p>「这首歌叫做『什么都没有』！」阿绿说道。歌词很奇怪，旋律也很奇怪。</p><p>我一边听着那首莫名其妙的歌，一边想着如果加油站着火了，那么火苗会吹向这栋房子吧！阿绿唱累了就把吉他放下，像一只晒太阳的猫咪似地靠在我的肩膀上。</p><p>「我作的歌怎么样？」阿绿问道。</p><p>「独创的佳作！完全将你个性表露无遗。」我很认真地回答。</p><p>「谢了！」她说。「歌名是『什么都没有』。」</p><p>「我可以了解！」我点点头。</p><h2 id="上下文"><a class="markdownIt-Anchor" href="#上下文"></a> 上下文</h2><p>想为你做一道菜，但是我没有锅子。</p><p>想为你编一条围巾，但是我没有毛线。</p><p>想为你写一首诗，但是我没有笔。</p><p>「这首歌叫做『什么都没有』！」阿绿说道。歌词很奇怪，旋律也很奇怪。</p><p>我一边听着那首莫名其妙的歌，一边想着如果加油站着火了，那么火苗会吹向这栋房子吧！阿绿唱累了就把吉他放下，像一只晒太阳的猫咪似地靠在我的肩膀上。</p><p>「我作的歌怎么样？」阿绿问道。</p><p>「独创的佳作！完全将你个性表露无遗。」我很认真地回答。</p><p>「谢了！」她说。「歌名是『什么都没有』。」</p><p>「我可以了解！」我点点头。</p><p>「嗯！那是我母亲死的时候……」阿绿对着我说。</p><p>「哦？」</p><p>「我一点都不悲伤！」</p><p>「哦？」</p><p>「后来我父亲离开，我也是一点都不悲伤！」</p><p>「是吗？」</p><p>「是的！你不觉得我很过分吗？不觉得我太过冷酷吗？」</p><p>「你会这样，一定有很多原因吧！」</p><p>「是啊！有太多原因了！」阿绿说。「我家实在太复杂了。但是，我总以为不管怎么样，他们总是我的父母，如果死了或离别，应该会悲伤的。但是我却不悲伤。一点感觉也没有。不悲伤、不寂寞、不痛苦，甚至不想念他们！只是常常会在梦中出现。母亲从黑暗的深处瞪着我看，然后责备我说『你很高兴我死掉！对不对！」我并不高兴呀！我母亲去世这件事。我只是没有那么悲伤而已。老实说，我连一滴眼泪都没有掉。小时候，我养的一只猫死掉时，我哭了一整个晚上！」</p><p>为什么会冒出这么多烟来呢？我想着。看不见火苗，也没有蔓延的样子，只有黑烟不断往上飘。到底在这么长的时间里烧掉了什么东西？我真是想不透。</p><p>「不过，那也不全是我的错。虽然我承认有薄情之处，但是，如果他们我父亲和母亲再多爱我一点的话，我想我会有不同的感受，会更悲伤难过的！」</p><p>「你认为他们不太爱你？」</p><p>她转头看着我的脸，然后用力点点头。「大概在不完全爱与完全不爱之间吧。我一直很渴望他们的爱。即使一次就好，我渴望拥有完全的爱！能让我觉得够了、饱了，能够说『谢谢这一顿饱餐』那样的爱。一次就好！仅仅一次就好！但是他们一次也没有给我！我一撒娇就被推开，抱怨我是赔钱货。一直都是这样。因此我私下决定，要自己去寻找一个永远都会百分之百爱我的人。小学五、六年级的时候，我就下了这样的决心！」</p><p>「了不起！」我佩服地说道。「那么，有没有成果？」</p><p>「很难。」阿绿说。然后望着烟想了一下。「大概是等了大久了吧！我追求完美的东西。所以很难。」</p><p>「你要一份完美的爱？」</p><p>「也不是。我没有资格要求那样。我追求的是一种单纯的真情，一种完美的真情。比方说，现在我跟你说我想吃草莓蛋糕，你就丢下一切，跑去为我买！然后喘着气回来对我说：『阿绿！你看！草莓蛋糕！』放到我面前。但是我会说：『哼！我现在不想吃啦！』然后就把蛋糕从窗子丢出去。我要的爱情是这样的。」</p><p>「但是我觉得这和爱情完全没有任何关系嘛！」我稍稍愕然地说道。</p><p>「有啊！只是你不知道罢了。」阿绿说道。「对女人来说，这其中有很重要的意义！」</p><p>「你是说把草莓蛋糕丢出窗外这件事？」</p><p>「是啊！我希望对方会说：『知道了！阿绿，我知道啦。我应该早晓得你不会想吃草莓蛋糕，我真是笨得像驴子一样不用大脑。对不起！我再去给你买别的。你喜欢什么？巧克力泡芙？还是起士蛋糕？』」「然后呢？」</p><p>「如果他这样对我，那我一定死心踏地爱他罗！」</p><p>「我觉得这话不尽合理。」</p><p>「但是对我来说，这就是爱。虽然没有人了解我。」阿绿说着，就在我的肩膀上轻轻地摇摇头。「对于某一种人来说，爱情就是从一些很琐碎、无聊之处开始的。甚至不这样，就无法开始。」</p><p>「我第一次遇到像你这种想法的女孩。」我说。</p><p>「对我说这句话的人可就多了。」她一面把弄着手指头，一面说：「但是，我是认真地这么认为。我只是说老实话而已，我从来没想过要有与众不同的想法，也不追求特别的东西。但是我说了实话，别人却以为是玩笑或作戏！所以常常增添许多麻烦。」</p><p>「所以你才想死在火灾里。」</p><p>「哎唷！不是啦！那只是一种好奇心罢了。」</p><p>「死在火灾里？」</p><p>「不是。我是想看看你会有什么反应。」阿绿说。「不过，死亡的本身，我一点都不害怕。真的！被这种烟雾包围，然后失去知觉就这样死去，只不过是一瞬间而已，一点都不恐怖。我母亲或其他亲戚，他们都是生了大病，好不容易脱离痛苦而死的。他们总算和我有血缘关系。他们从生病到死去都经过了相当长的时间，最后连自己是生是死都不知道。如果说还有一点残存的意识，也只是痛苦的感觉罢了。」</p><p>阿绿衔着一根万宝路香菸，点上火。</p><p>「我怕的是这种死亡方式。死亡的阴影一点一点地侵蚀着生命的领域，当你发现时，已经是一片漆黑，什么也看不见了。周围的人也觉得与其说我是活人，不如说更近于死人。这种情况是最令人憎恶的，我是绝对无法忍受的。」</p><p>又经过三十分钟之后，火灾才完全平息。好像没有蔓延，也没有人员伤亡的样子。留下来的那辆消防车也要回去了，人群也吱吱喳喳地走回店里去。只剩下管制交通的巡逻车留在路上，警灯在那里不停地转动着。不知道哪里飞来的两只乌鸦停在电线的顶端，正在眺望着地上的景况。</p><p>火灾一旦结束，阿绿就显得没精打采，全身无力地茫然眺望远空。而且几乎不说一句话。</p><h2 id="绿子的信"><a class="markdownIt-Anchor" href="#绿子的信"></a> 绿子的信</h2><p>前略。</p><p>现在你去买可乐，我趁这段时间写这封信。写信给一个坐在旁边的人，对我而言乃是第一次。但若不这样做，我就不能把我要说的话传达给你了。其实，不管我说什么，你都几乎没听进去。对不？</p><p>你知道吗？今天你对我做了一件残忍的事。你根本没察觉我的发型改变了，是不？我辛辛苦苦地把头发留长，好不容易在上星期才能换了一个有女人味的发型。而你竟然浑然不觉。这个发型肯定好看。而且我们好久不见了，我以为你见到我会吓了一跳才对，但你完全当我透明，是不是太过分？大概你连我穿什么衣服也想不起来吧。我也是女孩于。不管你有什么心事都好，起码应该好好看我一眼吧：只要你说一句「你的发型好可爱」，其后不管你怎么想怎么做，我都会原谅你。</p><p>因此我向你撒了谎。我说我和姐姐约好在银座碰头是骗你的。我本来打算今天到你家过夜，连睡衣也带来了。不错，我的袋子里面有睡衣和牙刷。哈哈，我好傻。因你根本没邀我到你家去。不过算了，你似乎觉得我在不在都无所谓，你像是希望一个人独虚的样子，我就让你独处好了。请你尽情去胡思乱想好了。</p><p>不过，我也不是十分气你。我只是觉得寂寞极了。因你对我百般亲切，而我好像不能为你做什么。你一直把自己关在自己的世界里，虽然我咚咚咚地敲门叫渡边，你仅仅台台眼，又马上回到自己的世界。</p><p>现在你拿看可乐走回来了。好像一面走一面想心事，我希望你摔一绞就好了，但你没有。如今你坐在我旁边，咕咕声喝看可乐。我期待你买可乐回来时会发现，然后说「哦，你的发型改变啦。&quot;毕竟希望落空了。若是件察觉到了，我会把这封信撕碎，告诉你说&quot;吱，到你那儿去吧：我为你做一顿好吃的晚餐，然后亲亲热热地一起睡觉。」然而你就像铁板一般粗心大意。再见了！</p><p>P.S. 下次在教室见面时，请不要跟我讲话。</p><h2 id="直子"><a class="markdownIt-Anchor" href="#直子"></a> 直子</h2><p>直子从口袋里伸出左手，握住我的。「不过你没关系。你不必担心啦。就算在黑夜里到这儿来『盲盲』然地走上一遭，你也绝对不会掉进井里的。所以说，我只要紧跟着你，就不会掉下去了。」</p><p>「绝对？」</p><p>「绝对！」</p><p>「你怎么知道？」</p><p>「我知道呀！就是知道嘛！」直子紧紧地握住我的手，一边说道。然后，有好一段时间默默地走着。「那种事我马上就能知道。没有什么理由，只是感觉而已。像今天晚上我一直跟着你走。就一点儿也不害怕。不管是多坏多黑暗的东西都引诱不了我！」</p><h2 id="上下文-2"><a class="markdownIt-Anchor" href="#上下文-2"></a> 上下文</h2><p>直子从口袋里伸出左手，握住我的。「不过你没关系。你不必担心啦。就算在黑夜里到这儿来『盲盲』然地走上一遭，你也绝对不会掉进井里的。所以说，我只要紧跟着你，就不会掉下去了。」</p><p>「绝对？」</p><p>「绝对！」</p><p>「你怎么知道？」</p><p>「我知道呀！就是知道嘛！」直子紧紧地握住我的手，一边说道。然后，有好一段时间默默地走着。「那种事我马上就能知道。没有什么理由，只是感觉而已。像今天晚上我一直跟着你走。就一点儿也不害怕。不管是多坏多黑暗的东西都引诱不了我！」</p><p>「那还不简单？你就一直跟着我好了！」我说。</p><p>「嗯——你是真心的？」</p><p>「当然是真心的罗！」</p><p>直子忽地停下脚步，我也跟着停了。她将两只手搭在我肩上，从正面凝望着我的眼睛。在她的明眸深处，一洼浓黑的液体聚成一种奇妙的图形。这么一对美丽的眸子盯了我好久好久。然后她踮起脚，轻轻地将她的脸颊贴上我的。这动作棒透了，暖得教人感到胸口一阵紧缩。</p><p>「谢谢！」直子说道。</p><p>「不客气！」我说。</p><p>「你能对我说那些话，我太高兴了。真的！」她哀切地边微笑边说道。「不过，那是不可能的。」</p><p>「为什么？」</p><p>「因为不能那么做！那样太过份了。那是——」话才到嘴边，直子突然又吞了回去，然后继续踱步。我知道现在她的脑子里有太多念头正在团团转着，因此我也不开口，只默默地走在她身边。</p><p>「那是——错的，对你对我都是。」久久，她才接着说道。</p><p>「怎么个错法？」我用平静的声音问道。</p><p>「因为没有谁能够永远保护另一个人呀！那是不可能的。听着，假设说我和你结了婚好了！你会上班吧？那你去上班的时候谁来保护我呢？难道我能跟着你一辈子吗？你看这公平吗？这还能叫做人际关系吗？而且总有一天你一定会觉得腻了。我的人生到底在干啥呀？当这女人的秤砣吗？到时候你一定会这么自问的。我不喜欢这样！这样根本也解决不了我的问题呀！」</p><p>「总不会腻一辈子吧？」我将手贴在她的背上说道。「总会告一段落吧？等到告一段落，我们都得要重新考虑，今后该怎么做。到那个时候说不定还是你反过来帮我呢！我们需要随时盯着收支清算单过活吗，如果你现在需要我，你大可好好利用，不是吗？为什么非得这么固执不可呢？放松自已吧！你若是不肯放松，到头来就会变得硬梆梆的。放松自己，你会舒坦些的。」</p><p>「你为什么这么说？」直子的声音听来既可怕又冷漠，我直觉得自己似乎是说错话了。</p><p>「为什么？」直子盯着地面说道。「放松自己会觉得舒坦些，这一点我也知道呀！你说这些话有什么用呢？听着，如果我现在放松自己，我会整个垮掉！从前我就是这一套生活方式，今后也只能这样活下去！我只要放松自己一次，就无法再恢复原状了！我会垮掉，然后随风散去。你难道不能理解吗，连这些你都不能理解，还谈什么保护我？」</p><p>我默不吭声。</p><p>「我比你所想像的要复杂多了。阴郁、冷淡、复杂……你那时候为什么会和我上床？你别理我就好了。」</p><p>我们在一片悄然无声的松林里踱着步。小径上散见些死于夏末的蝉的骸，干干痒痒的。踩在脚下便发出哔哩啪啦的声响。我和直子像是在找寻什么似的，一边盯着地面，一边徐徐地在小径上踱步。</p><p>「对不起！」直子说道，然后轻轻地握住我的手腕，摇了摇头。「我并不想伤害你，别在意我说的。真的抱歉！我只是在生自己的气而已。」</p><p>「我想大概是因为我还不算真正地了解你吧！」我说。「我不顶聪明，想了解某些事物都得要花时间才行。不过只要有时间，我就可以好好地了解你，我可以比谁都了解你。」</p><p>我们伫立在那里，倾耳聆听这一片宁谧。我用鞋尖去踢蝉的残骸和松枝，从树隙间仰望天空。直子则将两手插进上衣口袋里，一动不动地陷入沈思。</p><h2 id="直子的信"><a class="markdownIt-Anchor" href="#直子的信"></a> 直子的信</h2><p>「谢谢你的来信。」直子这样写着。信是从直子老家直接转送来的。她信上还说，收到信并不意外，坦白说是非常的高兴。因为她也正在想是不是该赶快写封信给我。</p><p>读到这里，我先打开房里的窗户，脱了外套，然后坐到床上去。附近的鸽笼传来了鸽子的叫声。风吹动着窗帘。我一手握着直子写来的七张信纸，置身于毫无边际的冥想之中。才只读了最开头的几行，就感觉到我周围的世界逐渐夫去了色彩。</p><p>我闭起眼睛，花了很长的时间去整理出一个情绪。然后做了一个深呼吸，再继续读下去。「来到这里已经将近四个月了。」直子继续写道。</p><p>「我在这四个月里，很仔细地考虑过你的事情。越考虑就越觉得自己这样对待你有失公平。因为我想我对你应该更认真、更公平一点。</p><p>不过这种想法或许又不是很认真的。为什么呢？因为像我这个年龄的女孩是不应该使用『公平』这种字眼的。对于一个普通的年轻女孩来说，事情的公平与否根本是无关紧要的。一般的女孩并不以是否公平，而是以美丽与否和幸福与否来做为考虑问题的中心。『公平』这种字眼总觉得是男人使用的字眼。但是现在我却觉得『公平』这个字非常地贴切。大概是因为美丽与否、幸福与否这些对我来说，是太过麻烦而复杂的问题，所以我只好找一个其他的标准了。比方说是否公平？是否诚实？是否普遍？</p><p>无论如何，我认为我自己对你并不公平。而且太拖累你、太伤害你了。不过我自己也因此受了拖累，受了伤害。我并不是要解释，也不是为自己辩护，而只是事实。如果我在你身上留下了什么伤痕，那不只是你的伤痕，同时也是我的伤痕。所以请不要因此憎恨我。我是一个不健全的人。比你所想像的还不健全。所以我不希望你恨我。如果你恨我，我真的是会心碎。我无法像你一样躲进自己的壳里去过日子。虽然我不了解真正的你，但我就是这样觉得。所以我常常会很羡慕你，甚至过分去拖累你，或许就是这个原因也说不定。</p><p>这种说法也许太过于理论分析了。你觉得呢？这里的治疗可不会太过于理论分析。不过，置身于我这种立场，接受几个月的治疗，多多少少也会变得更有分析性。因为治疗总是说这之所以如此是因为某种原因，而那又意味着什么？这种分析法到底是把世界单纯化呢，还是细分化呢？我完全不知道。</p><p>总之，我自己也感觉到我已经比以前好多了，而且周围的人也都这么认为。我已经很久没有这么冷静地写信了。七月时寄给你的那封信，是以一种被困绑的心情写的（老实说，我已经完全想不起来写了什么，是不是写得很不好？）这次我是十分平静地写的。清洁的空气与外界隔离的宁静世界，规律的生活和固定的运动，这些事物对我来说似乎是必要的。能够写信真是一件美好的事情！想把自己的想法告诉别人，于是坐在桌子前拿起笔来，写起文章，这真是太棒了！虽然写出来的东西只能表达一部分自己想说的事，但是没有关系。因为能够有写信给人的心情，对现在的我来说，已经是一种最大幸福了。因此我现在要写信给你。现在是晚上七点半，我已经吃过晚饭、洗了澡。四周是一片寂静，窗外是一片漆黑，没有一点光线。平常可以看见很美的星星，但是今晚有云，所以看不见一点星光。住在这里的人都对星星很了解，他们都会告诉我哪个是处女座，哪个是射手座。大概是太阳下山之后无事可做，所以即使不喜欢星星，却也知之甚详。基于相同的理由，这些人对鸟、花、虫、鱼也很了解。跟这些人一聊天，才知道自己对于很多事情是那么地无知，不过我却很高兴自己有这样的感觉。</p><p>总共有七十人左右住在这里。其他有二十几位工作人员（医生、护士、事务人员）。因为地方很大，所以人数并不算多。而且都显得很悠闲的样子。这里既宽敞又充满了自然的气息，每个人都过着非常平静的生活。由于太平静了，常常会觉得这里好像不是一个真实的世界。不过，当然不是如此。因为我们是在某一种前提下才住进这里的，自然也就习惯了这一切。</p><p>我在这里还打网球和篮球。蓝球队是由患者（虽然这个字眼很讨人厌，但是也没办法。）和工作人员组成的。不过由于全心投入比赛中，我会渐渐忘记谁是患者，谁是医生。那真是很奇怪的感觉。虽然说很奇怪，但是一边打球一边看周围的人，就会觉得每一个人都是同样扭曲的。</p><p>有一天，我把这个看法告诉主治大夫，他对我说，你的这种感觉在某种意义上是正确的。他说我们到这里来不是矫正扭曲的，而是要来学习适应那种扭曲的。他又说我们的问题之一，就是无法承认并接受那种扭曲。就像每一个人都有他独特的走路方式一样，感觉、思考和看法也都有不同的地方，即使想改正也不是一蹴可及的，如果勉强修正，恐怕别的地方又会变得很奇怪。当然这是很单纯的说明，而且只不过是我们问题中的一小部分，但我还是了解他所想要说的。或许我们是真的无法适应自己的扭曲吧！所以就没有办法把这种扭曲所引起的真实痛苦好好地加以定位，因此只好远离它，进到这里来。在这里我们不会去折磨别人，别人也不会折磨我们，为什么呢，因为我们每一个人都知道自己是『扭曲』的。这就是这里与外面世界完全不同的地方，外界有很多人都不晓得自己是扭曲的。但是在我们这个小小的世界里，扭曲正是一个前提条件。我们就像印地安人那样在头上插着代表本族的羽毛，承认自己的扭曲。所以能够不伤害彼此地安静渡日。</p><p>除了做运动之外，我们还自己种菜。有蕃茄、茄子、小黄瓜、西瓜、草莓、葱、莴苣、白萝卜，还有很多很多。我们种植各种东西，还使用温室。这里的人都对蔬菜的种植既了解又热心。他们看书、请教专家、从早到晚都在谈论着哪一种肥料比较好？土质又如何？我也很喜欢蔬菜。看着各种水果和蔬菜每天一点一点成长的情形，不禁令人雀悦。你有没有种过西瓜？西瓜成长的方式简直就像慢慢长大的小动物一样呢！</p><p>我们吃这些自己种的蔬菜和水果。虽然也有鱼和肉，但是我们都愈来愈不想吃那些东西。因为蔬菜实在是又美丽又可口。我们也会出去采山菜和野菇。同时还有专家（他们确实是专家唷！）告诉我这个可以采，那个不可以采。因此我来这里之后胖了三公斤。正好是标准体重呢！最主要是因为运动和规律正常的饮食。</p><p>其他的时间我们就看看书、听听音乐、编织一些东西。虽然没有电视和收音机，但却有设备齐全的图书室和一间唱片图书馆，收藏着马拉（译注：音乐家）的交响乐全集，以及披头四的乐曲，我常常在那里借唱片回房去听。</p><p>这里的设备唯一的问题就是，一旦进来这里，如果再出去外面，简直就是万劫不复，外面实在太可怕了。我们在这里才能拥有平静安宁的心情。也才能以自然的态度面对自己的扭曲，觉得自己有希望痊愈。但外面的世界是不是也能同样地接受我们呢？我实在没有把握。</p><p>主治医师说我就要进入可以与外人接触的时期了。所谓的『外人』就是指正常世界的正常人而言，但是在我心中只浮现一个你。老实说，我并不太想见双亲。因为他们对我的事感到很纷乱，即使见了面说了话，也只会让我陷入悲哀的心情中。而且我还有几件事一定要对你说。虽然我不晓得是否能够说清楚，但都是很重要的事情，也是不能再逃避的问题。</p><p>虽然如此，请你不要把我的事变成你的沈重负荷。我不想成为任何人的负荷。我只是要告诉你，我能感受到你对我的好，我只是要把这种欢喜之情老老实实告诉你罢了！大概是因为现在的我非常需要你的好意吧！如果我所写的话有什么让你迷惑的地方，我先向你道歉。请原谅我！就像我前面写的，我是一个比你想像中还不健全的人。</p><p>我常常会这么想如果我和你是在一种自然而普通的状况下相遇，我们彼此接受对方的好意，那会变成怎么样呢？我也很认真、你也很认真（从一开始就很认真唷！）如果没有木漉又会变成怎么样呢？虽然这个『如果』假设得实在太过分，但至少我会更公平、更诚实一点吧！现在的我也只能这么做了。所以找才希望你能稍微了解我的心情。</p><p>这里和普通的医院不同，探访时间在原则上是很自由的。如果在前一天先以电话连络，那就随时都可以见面，还可以一起吃饭，也有过夜的地方。如果你方便的时候，请来一趟。我会愉快地等着见你。信中并附上地图。信写得很长，请原谅！」</p><blockquote><p>摘录自《挪威的森林》叶惠译本</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;绿子&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#绿子&quot;&gt;&lt;/a&gt; 绿子&lt;/h2&gt;&lt;p&gt;「可爱极了！」&lt;/p&gt;&lt;p&gt;「绿子，」她说，「要加上名宇。」&lt;/p&gt;&lt;p&gt;「可爱极了，绿子。」我补充道。&lt;/p&gt;&lt;p&gt;「极了是怎么个程度？」&lt;/p
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>对待生活要把自己当作祭品</title>
    <link href="https://leay.net/2022/09/03/life/"/>
    <id>https://leay.net/2022/09/03/life/</id>
    <published>2022-09-02T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.588Z</updated>
    
    <content type="html"><![CDATA[<p>第二个本命年了，面对种种为人处事细节上的缺失，我还在拿这现象再常见不过当作借口：幼时缺少对人们如何交往的耳濡目染；要么被排挤要么埋头念书，也没能掌握怎么与人相处。一切，都要到被抛入那个场景的时机才有所意识，而我——们这类人总是不犯错就无法学会任何东西。虽然尝试了，去模仿、练习、生活。但那些对别人来说好像是生理反应的表现，总要在你脑子里转好几圈才做得出来。你一边在人群里笑一遍能意识到自己脸部的肌肉快要僵硬，心里尴尬且乏味。</p><p>「这有必要吗？」你从未拥有，因此能看出它的赘余。</p><p>你并不相信性格这类说法，只有一个又一个的人格面具。假如有套在哪都能获得正反馈的面具，不就一直戴下去啰。你改变了，连以前的熟人都会感到惊讶，效果不错。但在别人遵守社交规则试图找你做些浪费时间的事以增进感情时卡壳了——下一步该怎么做？你从不是一个需要靠外包情绪以自洽的人，因此也不曾体会过这样的礼尚往来。你因缺乏经验而感到——兴奋还是恐惧？你怯弱了，没有进一步去失败，反倒缩了回去，质疑自己「这有何必要」。</p><p>你也许仍然是个友善的人——对此有很多说法——但你不是没有感情，只是依赖其他人的那一部分似乎真的要消失了。说到底，你不奢求被爱了。你选择把自己当作礼物勇敢而真诚地送进这个世界，抛开一切统计意义上的障碍，热情地面对每一个人、每一件事。坦然地以自己的方式去爱人——以自己的方式。</p><p>然而大部分人都只能意识到他们希望得到的爱——你介意这点吗？不介意就停在这吧。否则倘若你不可避免地带有一丝期望，最好的方式仍然是去理解，稍微考虑别人的意见行事。</p><p>然后最重要的，作为大部分人之一，你——也许正被很多人以他们自己的方式笨拙地爱着。如果碰巧那正是你期望的方式，这样的事实抵得上整个世界的论证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第二个本命年了，面对种种为人处事细节上的缺失，我还在拿这现象再常见不过当作借口：幼时缺少对人们如何交往的耳濡目染；要么被排挤要么埋头念书，也没能掌握怎么与人相处。一切，都要到被抛入那个场景的时机才有所意识，而我——们这类人总是不犯错就无法学会任何东西。虽然尝试了，去模仿、练
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="杂文" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="杂文" scheme="https://leay.net/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>《卡拉马佐夫兄弟》译本对比</title>
    <link href="https://leay.net/2022/09/01/%D0%91%D1%80%D0%B0%CC%81%D1%82%D1%8C%D1%8F-%D0%9A%D0%B0%D1%80%D0%B0%D0%BC%D0%B0%CC%81%D0%B7%D0%BE%D0%B2%D1%8B/"/>
    <id>https://leay.net/2022/09/01/%D0%91%D1%80%D0%B0%CC%81%D1%82%D1%8C%D1%8F-%D0%9A%D0%B0%D1%80%D0%B0%D0%BC%D0%B0%CC%81%D0%B7%D0%BE%D0%B2%D1%8B/</id>
    <published>2022-08-31T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.598Z</updated>
    
    <content type="html"><![CDATA[<p>我翻阅了臧仲伦、耿济之、徐振亚/冯增义、荣如德几位老师四个译本的第一章。四个译本当然都是佳作，差别也更多体现在各位老师的翻译理念而非能力。短短第一章可能尚未展现陀翁的精彩处，而我自己对文字的感受力实在不够敏锐，故也只能区分出文本中显而易见的异同。挑选一些段落分享下，也许能为正准备阅读，挑选译本的朋友提供些许帮助。</p><hr><p>臧仲伦：有座小村庄和一处相当好的在城里的房子，也列入她的陪嫁之列，长时间以来，他一直变着法儿想把这些财产过户到他自己名下，而要做到这点，只要立一纸适当的文据就行，单凭他夫人对他的蔑视和厌恶，单凭这一点，他就不难达到自己的目的，而他无时无刻不在用自己的无耻勒索和苦苦哀求，来激起她对他的蔑视和厌恶。<mark>单凭她心里对他腻味透了，不想跟他纠缠，他就能如愿以偿。</mark> 但是，幸好阿杰莱达·伊万诺芙娜的娘家出面干涉，才限制了这个巧取豪夺的无耻之徒。</p><p>耿济之：在她的嫁资中，还有一个小庄园，和一所相当好的、城里的房子，他长时间地千方百计想通过办成一种相当的手续，弄到自己的名下；<mark>只要凭着他无时无刻不使用的那种无耻的勒索和苦求的手段，来引起自己夫人对他的轻蔑和厌恶，好在她精神疲劳时为了摆脱他而答应下来了事，他原是可以达到自己的目的的。</mark> 但是阿杰莱达·伊凡诺芙娜娘家出来干涉了，终于万幸限制了强夺的行为。</p><p>徐振亚/冯增义：她的嫁妆还包括乡下的一座庄园和城里一幢相当不错的房子，他一直都在处心积虑地想通过某种合法的手续把这两处财产转到自己名下，<mark>他每时每刻都厚着脸皮跟妻子硬磨软泡，苦苦哀求，以期引起妻子对他的蔑视和讨厌，最后惹得她心烦意乱，只要能摆脱他的纠缠，就同意答应他的要求。</mark> 他这一手本来肯定能得逞的，但幸亏这时候阿杰莱达·伊凡诺芙娜的娘家出来干涉了，才使这个贪得无厌的家伙有所收敛。</p><p>荣如德：作为陪嫁，她还得到一个小村庄和一栋挺不错的城里房子，丈夫在很长一段时间内千方百计企图通过某项适当的手续把它们转到自己名下。<mark>他一刻不停地厚着脸皮胡搅蛮缠、软磨硬逼，惹得妻子对他鄙夷至极、讨厌透顶，以致心力交瘁，只想摆脱。</mark> 老实说，单单由于这个缘故，他本来十拿九稳可以达到目的，但幸亏阿黛拉伊达·伊万诺夫娜的亲属出来干预，那个贪心鬼才不得不有所收敛</p><hr><p>臧仲伦：最后，她终于离家出走，抛弃了费奥多尔·帕夫洛维奇，<mark>跟一个穷得要命的神学校的教员私奔了</mark>，把一个三岁的孩子米佳留给了费奥多尔·帕夫洛维奇抚养。</p><p>耿济之：最后，她终于抛弃了家庭，离开费多尔·巴夫洛维奇，<mark>同一个穷得快要活不下去的宗教学校的教员私奔了</mark>，给费多尔·巴夫洛维奇留下了三岁的米卡。</p><p>徐振亚/冯增义：最后，她终于抛弃了这个家，离开费奥多尔·巴夫洛维奇，<mark>跟一个穷困潦倒的神学校教师私奔了</mark>，留给费奥多尔·巴夫洛维奇一个三岁的儿子米佳。</p><p>荣如德：后来，她终于离家出走，<mark>跟一个穷得叮当响的师范学校毕业生跑了</mark>，把三岁的米嘉丢给丈夫。</p><hr><p>臧仲伦：费奥多尔·帕夫洛维奇在夫人出走后便立刻在家里养了一大群女人，大张宴席，大肆酗酒，<mark>而在吃喝和玩女人之暇，差点没跑遍全省，</mark> 眼泪汪汪地逢人便诉说阿杰莱达·伊万诺芙娜抛弃了他，<mark>还告诉别人任何一个做丈夫的都羞于为外人道的床笫细节。</mark></p><p>耿济之：费多尔·巴夫洛维奇马上就在家里养了一大群女人，大肆酗酒放荡。<mark>间或清醒时，他就走遍全省，</mark> 含着眼泪对一切人抱怨抛开他的阿杰莱达·伊凡诺芙娜，<mark>还说出一些做丈夫的羞于出口的闺房琐事。</mark></p><p>徐振亚/冯增义：费奥多尔·巴夫洛维奇马上把一大群姘妇领到家里，毫无节制地酗酒作乐，<mark>抽空还跑遍全省各处，</mark> 向碰到的每个人哭哭啼啼地诉苦，把抛弃他的阿杰莱达·伊凡诺芙娜数落一番，<mark>同时还详详细细告诉大家那些做丈夫的羞于启齿的床笫琐事。</mark></p><p>荣如德：费奥多尔·巴甫洛维奇立即在家里养起了一大帮女人，成日价纵酒狂欢。<mark>在放荡的间歇中，他几乎跑遍了全省各地，</mark> 一把眼泪一把鼻涕地向所有的人哭诉阿黛拉伊达·伊万诺夫娜如何把他抛弃，<mark>同时还叙述种种细节，一个做丈夫的居然好意思细说自己婚后生活中的这些事儿，也太不识羞了。</mark></p><hr><p>臧仲伦：有些说话爱带刺的人对他说道： <mark>「您呀，费奥多尔·帕夫洛维奇，倒像升了大官似的，尽管您悲悲戚戚，但样子还挺得意。」</mark> 很多人甚至补充道，他还挺高兴他这小丑换了副模样，为了招人笑，甚至还故意装出一副他没发现自己滑稽可笑的模样。</p><p>耿济之：有些好嘲笑人的人对他说：<mark>「人家以为您，费多尔·巴夫洛维奇，加官进爵了，所以您不管怎样悲痛，还是十分得意。」</mark> 许多人甚至补充说，他喜欢以丑角的新姿态出现，为了招笑，故意装出这副样子，似乎毫不在意自己的滑稽处境。</p><p>徐振亚/冯增义：那些喜欢嘲弄的人对他说：<mark>「您真行啊，费奥多尔·巴夫洛维奇，尽管您很伤心，可您升了官发了财，所以您很得意。」</mark> 许多人甚至补充说，他乐意充当一名面目焕然一新的小丑角色，为了使人们笑得更加痛快，还故意装出对自己可笑的处境满不在乎的样子。</p><p>荣如德：有些人当面挖苦他：<mark>「尽管您遭到这样的不幸，可是看上去那么扬扬得意，旁人还以为您费奥多尔·巴甫洛维奇做官了呢。」</mark> 许多人甚至还说，他对于自己能以翻新的小丑面目出现感到高兴，而且假装并没发现自己的处境有多么滑稽，那是故意让人觉得更加可笑。</p><hr><p>臧仲伦：原来，这可怜的女人在彼得堡—她跟那个神学校的老师辗转来到了这个首善之区，<mark>无所顾忌地实行起了彻底的妇女解放。</mark></p><p>耿济之：这不幸的女人同她的宗教学校教员到了彼得堡，<mark>在那里肆无忌惮地彻底「解放」起来。</mark></p><p>徐振亚/冯增义：那个不幸的女人跟随自己的神学校教师辗转来到了彼得堡，<mark>并在那儿肆无忌惮地投身于最彻底的妇女解放运动了。</mark></p><p>荣如德：原来这可怜的女人和她的师范学校毕业生已一起迁往彼得堡，<mark>她在那里无拘无束地过起彻底解放的生活来了。</mark></p><hr><p>臧仲伦：就在这时候，他太太的娘家得讯：她在彼得堡不幸去世。<mark>她死得似乎很突然，死在一个阁楼上，有人传说，她死于伤寒，又有人传说她是饿死的。</mark></p><p>耿济之：就在这个时候，他的夫人娘家接到了她在彼得堡去世的消息。<mark>她好像死得很突然，就在一间阁楼上，有些人传说是由于伤寒，另一些人传说是饿死的。</mark></p><p>徐振亚/冯增义：就在这个时候，他妻子的娘家得到了她在彼得堡去世的消息。<mark>她好像是在一个阁楼里突然死去的，有人说她死于伤寒，也有人说她死于饥饿。</mark></p><p>荣如德：就在这个当口儿，他妻家获悉阿黛拉伊达·伊万诺夫娜已死在彼得堡。<mark>她不知怎么的一下子在某处的顶楼上死了，有的说死于伤寒，而另一种说法好像是饿死的。</mark></p><hr><p>臧仲伦：费奥多尔·帕夫洛维奇得知他太太去世的消息时正喝得酩酊大醉；据传，他当时跑上大街，快乐得向上苍举起双手，连声高呼：<mark>「如今解放啦！」</mark></p><p>耿济之：费多尔·巴夫洛维奇听见他夫人噩耗的时候正喝醉了酒，据说当时他跑到街上，快乐得双手朝天，开始呼喊：<mark>「这可好了！」</mark></p><p>徐振亚/冯增义：费奥多尔·巴夫洛维奇得悉妻子去世的消息时正喝醉了酒，据说他跑到街上，高兴得举起双臂大声喊道：<mark>「这下可好了！」</mark></p><p>荣如德：费奥多尔·巴甫洛维奇是在酒醉状态中得到妻子死讯的。据说，当时他跑到街上，兴奋地高举双手，仰天大喊：<mark>「现在放开了。」</mark>（<mark>译者注</mark>：这是基督教会举行葬礼时所念悼文中的语言。全句应为：「主啊，现在你放开了你的仆人，使之平静地离去。」此处可以理解成费奥多尔为「上帝放开了他的妻子」或「妻子放开了他」而兴高采烈。）</p><hr><p>臧仲伦：在大多数情况下，甚至坏蛋也比我们通常对他们的看法要天真得多和淳朴得多。我们自己亦然。</p><p>耿济之：在大多数情况下，一般人，甚至坏蛋，也常常比我们通常所认为的要天真烂漫得多。包括我们自己也是这样。</p><p>徐振亚/冯增义：多数情况下，所有的人，甚至坏蛋，也要比我们一般想象的更加天真幼稚，更加质朴善良。包括我们自己也是这样。</p><p>荣如德：在大多数情况下，人们，甚至恶人，要比我们想象中的他们幼稚得多、天真得多。其实我们自己也一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我翻阅了臧仲伦、耿济之、徐振亚/冯增义、荣如德几位老师四个译本的第一章。四个译本当然都是佳作，差别也更多体现在各位老师的翻译理念而非能力。短短第一章可能尚未展现陀翁的精彩处，而我自己对文字的感受力实在不够敏锐，故也只能区分出文本中显而易见的异同。挑选一些段落分享下，也许能为
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>人生的意义</title>
    <link href="https://leay.net/2022/07/07/life/"/>
    <id>https://leay.net/2022/07/07/life/</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.598Z</updated>
    
    <content type="html"><![CDATA[<p>说到「人生的意义」，首先我们可以将之转换为「为什么人会存在？」这样一个因果论问题讨论。单纯从逻辑上讲，这问题要么没有答案——因为每一个原因总还有个导致这个原因的原因（生物活动、原子碰撞……为什么会有这一切？）。要么就应该有个超验的原因——比方说上帝。</p><p>不严谨地讲，许许多多的哲学家都在试图找（定义）这个超验的原因，在康德那是「自由」；叔本华是「意志」；尼采是「权力」；黑格尔是「绝对精神」……</p><p>然后我们回过头来，有人提出了另外的见解——「人生的意义」这个说法不成立<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。当我们说「人生的意义」时，似乎真的有「人生」「意义」这样的东西存在，然而我们其实是被语言迷惑住了——我们像说「桌子上的书」一样来说「人生的意义」，在语法上替换词汇从而将「人生」「意义」这样的词汇具体化了。哲学家的任务不是解决这样的问题，而是找出这样的差异，消解它们。哲学就是一种治疗，把陷入这些问题的人解救出来——别纠结啦，「人生的意义」根本就不是问题。</p><p>但按照研究语言学的学者的说法，可以将「意义」的含义区分为作为结构的意义和作为动作的意义。</p><ul><li>作为结构的意义：指的是词汇在在语言结构中的意义。比方说「人生的意义」中的「的」，我们光看这个句子就能从语法上分析出「的」在这里用作所属关系。在这个层面，「意义」作为一个词汇就有两种情况：<ul><li>它作为一个符号，我们可以赋予它一些意思（从这个角度讲，意义也许是我们主动赋予的）；</li><li>它像「的」一样只标志某种语法功能。</li></ul></li><li>作为动作的意义：指在使用词汇时的一个「意图」，这个意图常关联场景。比如我说「这个！」——其实我想表达的是「把这个东西拿给我」，而场景则是我指着一个苹果。当我们说「人生的意义」时往往不是在语法上使用它——比如我说「人生没有意义！」时其实有着「我的生活很空洞」这样的意图。</li></ul><p>当说「人生的意义」时，是否可能拥有一个类似于「某人意图表明什么」这样的意思？也就是说「有没有一个告诉我们如何生活的条条框框」？</p><p>这样一来，我们将「人生的意义」又拉回到开篇的因果论问题了。</p><p>但让我们尝试从另一个角度思考，不假定这个问题后面一定有个源头——前面说过，当我们溯因时，要么没有答案，要么整一个超验的东西作为答案，比如上帝、自由……那么「也许存在着某种意味深长的叙事深植于现实中，但它不具有任何超人的源头。」比如马克思主义者不相信神，但「历史」对他们来说有其意义<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。可能「人生的意义」就在这种模式当中？个人的意义通过这类宏大叙事彰显。</p><p>宇宙也许没有经过有意地设计，也肯定不是想表达点什么，但它深层次的规律仍显示出某种美感、对称和简洁，能令许多人感动落泪。</p><p>不过，意义一定是这样内在的吗？当从「内在」讨论时，有三种情况：</p><ul><li>一是试着描述某件实际存在的东西；</li><li>二是我们只能谈论我们能谈论的东西——一切意义都是人类的言语行为。也许人生具有一种我们所有人都一无所知且无法知道的意义，所谓的「内在的意义」不过是对世界的一瞥；</li><li>三是某种我们注入事物内部或当作事物本身性质来谈论的东西。</li></ul><p>也许生命不过是进化过程中的偶发现象，它与一缕微风的起伏或腹中的一声闷响一样，没什么意义呢？而且是荒谬的无意义<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>——<mark>你因为曾错误地想象这个世界可能本质上具有某种意义，因此失望地发现世界原来并无意义。</mark></p><p>为什么要失望呢？人生没有意义，我们可以去填充意义呀——就像食物吃完了就往冰箱装东西那样，解决方法明显掌握在自己手上。但这样的结论毕竟是经验性的，无法作为一个牢固的「内在」意义。如果人生要拥有某种意义，它当然不会是我们随意投射上去的。</p><p>比方说我们可以拿空调当武器砸开窗户——注入意义，但空调作为一个人工制品仍然有它本身的意义。当我们讨论「人生的意义」时，也许「人生」是被上帝或者其他什么力量所创造的，那么「人生」或许作为一件创造物有内在意义。</p><p>再换个方式来看。我们不去追问「内在」意义看起来是什么样的，而是考虑，或许意义是我们「建构」世界所得出的？</p><p>当讨论「建构」时，我们当然得先排除那些常出错的「主观诠释」——「你可以把老虎当作没有攻击性的动物，但会有被吃掉的风险」。人类可以自我决断——但只能建立在更深刻的对自然、现实世界的依赖以及人类相互依赖的基础之上。我为自己的人生所创造的任何意义，都在内部受制于这一依赖关系。我们无法从零开始。别人的人生意义、我的存在特征都会限制我的人生意义。意义——应该是我们与现实相互作用的产物。对意义的理解依赖于每个个体的创造，但每个个体的创造又依赖于对意义的理解。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>我们没办法完全不考虑亲属关系、死亡、疾病等等现实因素。</p><p>我们向这个世界发问，这些问题当然属于我们，而非世界本身。但这个世界回应的答案之所以对我们有益，恰恰是因为现实总比预期的更加丰富。现实超越了我们自己对它的解释，还时不时粗鲁地对待或挫败这些解释。意义固然是人们所做的事情，但人们是在与一个确定的世界的对话中做事的，而这个世界的运行规则不是人类发明的，并且人们的意义要想有效，他们就必须尊重这个世界的本质和特征。</p><p>不管从哪方面讨论，总存在些诸如健康、幸福这样符合内在价值的范畴，且我们愿意选择作为生活意义的东西。也许我们可以从这种种意义中挑选捏合属于自己的独特人生？</p><p>我们聊聊这几种常见的说法：</p><p>「幸福」可以充当人生的意义吗？如果你生活在一个肮脏又拥挤的难民营里面，并且刚刚在一次自然灾害中失去了孩子，你基本上不可能感到幸福。也许一个人「抱怨的时候最幸福」「别人不幸福时自己最幸福」。</p><p>「权力」能构成人生的意义吗？没有权力的人都知道权力多珍贵——就像财富一样，只有那些拥有很多这一资源的人才有能力鄙视它。</p><p>「财富」呢？本该用于在某种程度上将人类从劳动的迫切需求当中解放出来的资本，现在却被用来积累更多的资本。</p><p>「爱」又如何？<mark>爱是一件令人劳累和沮丧的事，充满挣扎与挫折，而不是笑嘻嘻的、傻头傻脑的满足感。</mark> 有人花了一辈子爱孩子，牺牲自己的幸福，尽管这种牺牲也许带着幸福的名义；为正义而斗争，是爱的一种表现形式，但这会给你带来死亡的危险。</p><p>「死亡」呢？我们在世间忙忙碌碌，仿佛能永生——一旦意识到 <mark>你终将死去</mark>，你会选择过怎样的生活？</p><p>「欲望」呢？但凡有东西缺失，欲望就会涌上来。欲望与匮乏有关，<mark>它把当下掏空，以便把我们送到某个同样掏空的未来。</mark></p><p>「精神上的沉思」呢？这是我们这些自诩「热爱阅读」的人最爱犯的毛病。把反思存在的真理当做人类最高尚的目标——这多方便呐，也许人生的意义就在于思考人生的意义这件事？它虽然是一种实践——但若是沉思到虚无主义、沉思到没有生活，那就很危险了。</p><p>「人生的意义」并非一个思辨问题，而是一个实践问题——我们通过语言来谈论问题，而语言通过行动诞生（想象原始人通过手势咿呀着交流）。当我们面临无限的因果链（意义是什么？意义的意义是什么？）时，最后的那个因一定是我们的行动。<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p><p>人类同属于一个自然物种，很大程度上具有共通性。如果人生的意义在于人类的共同目标，我们很容易基于「实践」推导出「爱」这种东西——人人为我、我为人人嘛。「爱」是我们调和个体实现和社会性动物之本性的方式，它表示为别人创造发展的空间，同时，别人也为你这么做。每个人自我的实现，成为他人的实现的基础。一旦以这种方式意识到我们的本性，我们便处于最好的状态。因为允许他人同样实现自我的方式实现自我，可以排除谋杀、剥削、酷刑、自私等因素。如果损害他人，长远地看也就是损害自我的实现，因为自我的实现必须依靠他人的自由参与。由于不平等的个体之间不可能有真正的互惠互利，以长远的眼光来看，压迫和不平等也会阻碍自身的发展。<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p><p>理想（但乌托邦式）的目标可能是幸福与爱的结合——每个人通过一种无目的的自我表达，自己幸福的同时这份幸福本身能给予身边人以爱，为别人的幸福做出贡献。</p><blockquote><p>本文源于 <a href="https://book.douban.com/subject/20273773/" target="_blank" rel="noopener">人生的意义</a>，有大量摘抄。如果文章有胡扯的地方，都是因为我功课没做足。若有人指正，感激不尽。</p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>尼采是19世纪最伟大的哲学家之一，在怀疑是不是出于语法的原因我们才无法摆脱上帝时，他已经比<a href="https://www.wikiwand.com/zh-hans/%E8%B7%AF%E5%BE%B7%E7%BB%B4%E5%B8%8C%C2%B7%E7%BB%B4%E7%89%B9%E6%A0%B9%E6%96%AF%E5%9D%A6" target="_blank" rel="noopener">维特根斯坦</a>先行一步。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>后现代主义坚称，只要我们还有深度、本质和根基，我们就仍然活在对上帝的敬畏之中。我们还没有真正把上帝杀死并埋葬。我们只是给他新换了一套大写的名字，如自然、人类、理性、历史、权力、欲望，诸如此类。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://www.wikiwand.com/zh-hans/%E8%8D%92%E8%AC%AC" target="_blank" rel="noopener">荒谬</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.wikiwand.com/zh-hans/%E8%A7%A3%E9%87%8B%E5%AD%B8" target="_blank" rel="noopener">解释学循环</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>这是我在胡说八道。= = <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p><a href="https://www.wikiwand.com/zh-hans/%E9%81%93%E5%BE%B7%E5%BE%8B%E4%BB%A4" target="_blank" rel="noopener">道德律令</a>、<a href="https://www.wikiwand.com/zh/%E6%97%A0%E7%9F%A5%E4%B9%8B%E5%B9%95" target="_blank" rel="noopener">无知之幕</a> ↩ <a href="#fnref6" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说到「人生的意义」，首先我们可以将之转换为「为什么人会存在？」这样一个因果论问题讨论。单纯从逻辑上讲，这问题要么没有答案——因为每一个原因总还有个导致这个原因的原因（生物活动、原子碰撞……为什么会有这一切？）。要么就应该有个超验的原因——比方说上帝。&lt;/p&gt;&lt;p&gt;不严谨地讲
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>让我们再尝试下好好说话——论「不是所有」</title>
    <link href="https://leay.net/2022/06/14/steelmanning/"/>
    <id>https://leay.net/2022/06/14/steelmanning/</id>
    <published>2022-06-13T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.583Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.wikiwand.com/zh-hans/%E7%A8%BB%E8%8D%89%E4%BA%BA%E8%AB%96%E8%AD%89" target="_blank" rel="noopener">稻草人论证</a> 是一种通过曲解对方的论点，并针对曲解后的论点（替身稻草人）攻击，再宣称已推翻对方论点的论证形式。与之相对的，<a href="https://www.wikiwand.com/en/Straw_man#Steelmanning" target="_blank" rel="noopener">钢铁侠策略</a> 是一种通过确定对方论点，甚至帮助对方构建出最恰当的论点，然后对此进行辩论的方式。前阵子聊过[[讨论何以可能|类似的想法]]，没想到还有个专门的说法。</p><p>我觉得这对试图从对话中有所收获，而不是享受攻击的快感的人来说，确实是值得使用的讨论技巧。</p><p>比方说面对一篇文章，应当以最理性的方式<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>去理解作者的表达——想象这个常见的场景，读者批评作者「你怎么不说什么什么」——当遇到作者似乎漏掉什么时，最好合理地考虑「这点是不是对论证文章的核心观点无益？」而不是「你太无知了，这也不知道。」或者「你忽略了那些，所以这篇文章是在以偏概全。」</p><p>最近读到 <a href="https://mp.weixin.qq.com/s/tuXmRMRxH7rFBYGyEITbsw" target="_blank" rel="noopener">Not All Men 为什么这么糟糕？</a>，文章批评了在讨论女权主义议题时插嘴「不是所有男人」的对话者，因为这是在破坏对话。</p><p>文章写得很好，但它似乎并没有对「不是所有」这个说法做出回应，而是通过描绘一幅「这样会如何」的糟糕图景反过来说「不是所有」这种说法是不好的。因此文章读起来不是那么客气，而且似乎对它的标题本身避重就轻。</p><p>我觉得，严谨的用词在实践上并不是必须的——比方说讨论女权问题时表达者可以给所有涉及「男性」的地方加一个限定词「部分」——「部分男性」，但同理倾听的人也可以去理解表达者，将词汇脑补一个限定词使之更「严谨」呀。</p><p>我们拥有无数种方式指责表达者「不够中立」或「挑拨情绪」——对于想要好好讨论的人来说，这样的批评并没有贡献任何价值；而对于那些真正激进地宣扬「所有男人都该死」的内容来说，也不会因为批评而把口号改成「部分男人该死」——后者搞不好在义正严辞地反驳后还会加重「果然对男人就是不能讲道理、就是应该拨乱反正」的信念。</p><p>说「不是所有」——就好像我们可以通过区分找到真正的「敌人」。这种思路确实也很必要，但现实是这样说的人往往就只停留于此。当我们说「不是所有」的时候，是在尝试将「男性」这个群体进行划分，而划分不可避免会涉及到程度问题——哪一部分人更需要对此负责？</p><p>那些说着「不是所有」的人就有必要区分这一点，并对「哪一部分更」做出阐明，不然就只是在当讨厌鬼——否则就让我们在这个程度上先讨论下去吧。</p><p>这当然有可能是一种偷懒——我讨厌一些创作者用「我只写给部分人」的借口掩饰自己实则不肯求证或另有考虑，讨厌把它当作铠甲听不得半点批评，讨厌自己也常常以艰深文浅陋。但这种心虚的模糊很容易和求知所犯的错误区分开来——通过你从文章读出的真诚。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.wikiwand.com/en/Principle_of_charity" target="_blank" rel="noopener">慈善原则</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.wikiwand.com/zh-hans/%E7%A8%BB%E8%8D%89%E4%BA%BA%E8%AB%96%E8%AD%89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;稻草人论证&lt;/a&gt; 是一种通过曲解
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="杂文" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="杂文" scheme="https://leay.net/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>软件系统的复杂度</title>
    <link href="https://leay.net/2022/06/13/complexity/"/>
    <id>https://leay.net/2022/06/13/complexity/</id>
    <published>2022-06-12T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.595Z</updated>
    
    <content type="html"><![CDATA[<p>《A Philosophy of Software Design》的作者通过衡量软件系统是否容易被理解和修改来定义「复杂度」。</p><p>「复杂」表现出三个症状：</p><ul><li><p><strong>Change amplification</strong>：一个看似简单的修改实际上却需要修改很多代码。</p><ul><li><p>比如说多个网页有着同样的背景色，却各自单独维护，因此想要改变多个页面的背景色就得同时改动多个页面的代码——我们很容易想到，可以通过维护一个共享变量来控制各个页面的背景色，这样只需要修改一次就能满足要求了。</p></li><li><blockquote><p>一堆字段重合度非常高的列表展示页，全都各自有一个页面。一次需求让将列表中部分字段脱敏展示，于是只能一个页面一个页面地修改。</p></blockquote></li></ul></li><li><p><strong>Cognitive load</strong>：认知负荷，指开发人员需要了解多少前提才能完成任务。更高的认知负荷意味着开发人员必须花费更多时间来学习所需的信息，并且存在更大的错误风险。</p><ul><li>比方说要修改一个 API 的返回值、业务逻辑，那至少得掌握这个 API 被多少地方调用。比方说同事 A 炫技写了个短却复杂的代码——看代码量是够精简的，可其它同事甚至他自己在后面修改时，都很难搞清楚这些代码在干嘛。假如函数名语义不明确、有副作用……都会增加开发人员认知负担。</li></ul></li><li><p><strong>Unknown unknowns</strong>：开发人员不知道自己不知道，他不知道必须修改哪些代码或者掌握哪些信息才能完成任务。</p><ul><li><p>比方说网站使用一个共享变量控制字体颜色，但一些网页却单独控制自己的背景色。因此对于大部分网页来说，更改字体颜色后没啥问题，但对于一些有着特殊背景色的网页，则有可能出现原来的背景色对于现在的字体来说太亮，导致网页没有可读性的情况。而即使开发人员意识到这样的问题，也不清楚具体涉及哪些特殊页面，因此又需要花大量时间排查。</p></li><li><blockquote><p>有次在项目 A 新增了一个异常码，而这类异常码会被另一个好久没动过的项目 B 用到，B 使用时需要将 A 的异常码转换成 B 的格式——没人意识到这点，结果问题在需求后期才暴露出来。</p></blockquote></li></ul></li></ul><p>造成「复杂」的两个原因：</p><ul><li><p>依赖关系：依赖不可避免，但应该尽量简单明了。</p></li><li><p>模糊：重要的信息不够明显就会变得模糊。比如变量名取的太通用了，完全搞不清楚它会被用于啥；（想象一个叫 <code>data</code> 的变量名）一个变量的文档没有说明单位，因此我们只能扫描代码看看使用这个变量的地方是怎么用的；模糊性经常和依赖关系相关，即依赖关系没那么明显——比如新增的错误码需要维护一个字符串，这个字符串对开发人员来说就没那么明显。</p><ul><li><blockquote><p>遇到过接口文档的一个金额字段的单位是「元」，而建表用的「分」。</p></blockquote></li></ul></li></ul><blockquote><p>书中举的例子都太他妈真实了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《A Philosophy of Software Design》的作者通过衡量软件系统是否容易被理解和修改来定义「复杂度」。&lt;/p&gt;&lt;p&gt;「复杂」表现出三个症状：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Change amplification&lt;/strong&gt;：一个
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>数组、越界及遍历</title>
    <link href="https://leay.net/2022/06/01/index-out-of-bounds/"/>
    <id>https://leay.net/2022/06/01/index-out-of-bounds/</id>
    <published>2022-05-31T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组越界检查"><a class="markdownIt-Anchor" href="#数组越界检查"></a> 数组越界检查</h2><p>在 C 语言里遇到数组访问越界时，虽然编译可能会有警告，但代码是能成功运行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>因为一个数组在计算机内表现为一段内存地址，当我们尝试越界访问数组时，实际上是在尝试越过那一段内存地址去访问别的内存地址上的数据——倘若我们尝试访问的地址是合法的，且又没做任何控制，那么自然也能访问到数据。</p><p>而在 Java 中类似逻辑的代码虽然能正常编译，但当 Java 虚拟机执行 class 文件时却会抛错 <code>ArrayIndexOutOfBoundsException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr[<span class="number">5</span>]);</span><br><span class="line">System.out.println(arr[-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>很容易想到是不是 JVM 层面做了什么控制——确实如此，比方说 hotspot 虚拟机里相关的控制实现如下：</p><ul><li><a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/interpreter/bytecodeInterpreter.cpp" target="_blank" rel="noopener">jdk8/jdk8/hotspot: 87ee5ee27509 src/share/vm/interpreter/bytecodeInterpreter.cpp</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotspot\src\share\vm\interpreter\bytecodeInterpreter.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_INTRO(arrayOff)                                                  \</span></span><br><span class="line">      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \</span><br><span class="line">      jint     index  = STACK_INT(arrayOff + <span class="number">1</span>);                               \</span><br><span class="line">      <span class="keyword">char</span> message[jintAsStringSize];                                          \</span><br><span class="line">      CHECK_NULL(arrObj);                                                      \</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)index &gt;= (<span class="keyword">uint32_t</span>)arrObj-&gt;length()) &#123;                     \</span><br><span class="line">          <span class="built_in">sprintf</span>(message, <span class="string">"%d"</span>, index);                                       \</span><br><span class="line">          VM_JAVA_ERROR(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), \</span><br><span class="line">                        message);                                              \</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>hotspot 将会判断访问数组的索引是否超过了数组的长度限制，若是，则抛出数组访问越界异常。</p><p>注意索引被转换成了 <code>uint32_t</code> 类型（无符号类型），因此当索引为负数时会被转换为相应的无符号类型数。Java 中数组的大小和 int 的取值范围有关，int 占 32 byte 大小，取值范围是 <code>-2147483648 至 2147483647</code>，因此负数的取值范围为 <code>-2147483648 至 -1</code>，相应的补码（用补码表示负数）的取值范围是 <code>2147483648 至 4294967295</code>。</p><p>显然为负数的索引在这会被判断超过限制从而抛出异常。</p><p>但比如说在遍历一个大号数组的场景下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">999999</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然数组的访问索引 <code>i</code> 的取值显然不会越界，那其实没必要每次访问数组的值时都进行一次越界检查——实际上 JVM 判断出这种情况后会进行「数组边界检查消除」的优化来减少性能浪费。</p><h2 id="jdk-层面的越界检查"><a class="markdownIt-Anchor" href="#jdk-层面的越界检查"></a> JDK 层面的越界检查</h2><p>Java 是在 JVM 层面对数组是否越界进行判断的，而对于集合对象来说，则在 JDK 层面进行越界检查。比方说 <code>LinkedList</code> 的 <code>get()</code> 中的越界检查实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历数组"><a class="markdownIt-Anchor" href="#遍历数组"></a> 遍历数组</h2><p>就简来说，Java 中有三种 for 循环用于遍历集合对象。（下面的 two 和 three 一般统称为 foreach 或 增强 for 循环，我做下区分方便讨论。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one 经典 for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size; i++)</span><br><span class="line">  System.out.println(arr.get(i))</span><br><span class="line"><span class="comment">// two 增强 for</span></span><br><span class="line"><span class="keyword">for</span>(T a : arr)</span><br><span class="line">  System.out.println(a)</span><br><span class="line"><span class="comment">// three foreach</span></span><br><span class="line">arr.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>比方说 <code>Iterable.java</code> 提供的 <code>foreach()</code> 的实现简单好懂，其实是在 JDK 层面利用 Lambda 表达式做参数，封装了增强 for：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java/lang/Iterable.java</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强 for 仍然是个语法糖，<mark>遍历集合时</mark>底层使用 Iterator，<mark>遍历数组</mark>时底层用的普通 for：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span> <span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; var1)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(var1);</span><br><span class="line">    Iterator var2 = <span class="keyword">this</span>. iterator():</span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext())&#123;</span><br><span class="line">        Object var3 = var2.next;</span><br><span class="line">        var1.accept(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;;</span><br><span class="line">String[] var2 = str;</span><br><span class="line"><span class="keyword">int</span> var3 = str.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">  String s = var2[var4];</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fail-fast"><a class="markdownIt-Anchor" href="#fail-fast"></a> fail-fast</h2><p>fail-fast 顾名思义，快速失败——让它崩溃！发现问题，马上让它暴露出来。</p><p>比如下面就是一个 fail-fast 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == name) <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">  <span class="comment">//……s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Java 集合中 fail-fast 体现为：当遍历集合对象时，若集合对象同时被进行了「结构性更改」的操作，则会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>啥是结构性更改呢？</p><blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html#modCount" target="_blank" rel="noopener">ListIterator (Java Platform SE 7 )</a></p><p>Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.</p></blockquote><p>我觉得后面这段有点暧昧「或者以其它方式扰乱数组，以至于正在进行的迭代可能会产生错误的结果」，什么其它方式？以及，什么错误的结果？</p><p>我理解结构性更改的方式有两种：</p><ul><li>集合对象中元素数目的变动（如 add()、remove()、addAll()、clear()……）</li><li>集合对象内部结构的更改<ul><li>这个要具体到集合对象的实现，比如 HashMap 的 rehash()、ArrayList 的 replaceAll()。</li><li>比方说 HashMap 的 set() 就不算结构性更改，为啥 ArrayList 的 replaceAll() 就算结构性更改？</li></ul></li></ul><p>至于错误的结果，按我的理解：</p><ul><li>比如对于 HashMap 来说，倘若遍历的途中进行了 rehash() 操作，显然遍历的结果会出问题。</li><li>比如对于 List 来说，倘若遍历的途中添加或删除了一些元素，会导致「也许部分添加的元素被遍历出来了而部分元素未能遍历」等数据不一致的情况。</li></ul><p>Java 实现 fail-fast 的方式很清晰——集合对象内提供了一个 <code>modCount</code> 元素保存对象进行结构性更改的次数。这样在遍历之前，会取一个 <code>modCount</code> 的快照作为期望值 <code>expectedModCount</code>，每次访问时会判断这个期望值与当前的 <code>modCount</code> 是否一致。倘若不一致，这说明遍历期间有人捣蛋，则抛出<code>ConcurrentModificationException</code> 异常。</p><p>比方说 <code>ArrayList.java</code> 的 <code>foreach()</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(action);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">  <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++)</span><br><span class="line">    action.accept(elementAt(es, i));</span><br><span class="line">  <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要在-foreach-循环里进行元素的-addremove-操作"><a class="markdownIt-Anchor" href="#不要在-foreach-循环里进行元素的-addremove-操作"></a> 不要在 foreach 循环里进行元素的 add/remove 操作</h2><ul><li>见 <a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">Alibaba Java Coding Guidelines</a></li></ul><p>这里的 foreach 循环如果指前文提到的第三种遍历集合对象的元素，那就简单了。比方说上面 <code>ArrayList.java</code> 的 <code>foreach()</code> 实现，很明显会抛出 <code>ConcurrentModificationException</code> 异常——「为什么不要？」因为会抛异常嘛。</p><p>但倘若指前文提到的第二种遍历方式，即增强型 for 循环——则没这么显然了。因为增强型 for 循环实际上是 Iterator 的封装，因此需要到 Iterator 的实现里去看看会发生什么事。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(<span class="string">"one"</span>);</span><br><span class="line">    arrayList.add(<span class="string">"two"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : arrayList)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">"one"</span>.equals(s))&#123;</span><br><span class="line">        System.out.println(arrayList.remove(s));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(<span class="string">"one"</span>);</span><br><span class="line">    arrayList.add(<span class="string">"two"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : arrayList)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">"two"</span>.equals(s))&#123;</span><br><span class="line">        System.out.println(arrayList.remove(s));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line">ArrayList var1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    var1.add(<span class="string">"one"</span>);</span><br><span class="line">    var1.add(<span class="string">"two"</span>);</span><br><span class="line">    Iterator var2 = var1.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">      String var3 = (String)var2.next(); <span class="comment">// next() 会检查集合对象是否进行结构性更改</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"one"</span>.equals(var3)) &#123;</span><br><span class="line">        System.out.println(var1.remove(var3));<span class="comment">// remove() 会记录为一次结构性更改</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Iterator 实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">int</span> i = cursor;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  cursor = i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比反编译后的 three 及其实现来看例子 one 和 two 的执行情况：</p><ul><li>例子 one 能正常执行：对例子 one 来说，第一次遍历便进行 remove()，此时游标 cursor 为 1，size 为 1，因此尝试第二次遍历时因为 hasNext() 为 false，跳出遍历。</li><li>而例子 two 会抛异常：对于例子 two 来说，第二次遍历进行 remove()，此时游标 cursor 为 2，size 为 1，因此尝试第二次遍历时因为 hasNext() 为 true，尝试进行第三次遍历，此时进入 next() 方法便抛出 <code>ConcurrentModificationException</code> 异常。</li></ul><p>看样子仍然很危险呐——因此还是不要在 foreach 循环里进行元素的 add/remove 操作吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组越界检查&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数组越界检查&quot;&gt;&lt;/a&gt; 数组越界检查&lt;/h2&gt;&lt;p&gt;在 C 语言里遇到数组访问越界时，虽然编译可能会有警告，但代码是能成功运行的：&lt;/p&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
    
      <category term="学习折腾" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/"/>
    
      <category term="自己浅见" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/%E8%87%AA%E5%B7%B1%E6%B5%85%E8%A7%81/"/>
    
    
      <category term="Java" scheme="https://leay.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>除了英雄我们还可以期待什么</title>
    <link href="https://leay.net/2022/05/28/hero/"/>
    <id>https://leay.net/2022/05/28/hero/</id>
    <published>2022-05-27T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.597Z</updated>
    
    <content type="html"><![CDATA[<p>马克斯·韦伯认为任何权力都不能持久地建立在强制或暴力基础之上，而必须具有合法性基础。在这个意义上权威即是建立在合法性基础之上的权力。从这一思路出发，韦伯抽象出三个理想化权威类型：传统权威、卡理斯玛权威<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>和法理权威。</p><ul><li>传统权威：顾名思义，是从历史上传承下来的习俗传统中得到合法性，如传统社会中的长老权威从沿袭已久的文化传统中得以维系和延续。</li><li>卡理斯玛权威：以领袖的超凡禀赋来获取追随者的认同拥戴，从而得到其合法性基础，这在社会运动如农民起义和各类集体行为中尤为突出。</li><li>法理权威：依据民众所认可接受的公正程序而得到合法性基础，例如经过选举程序产生的领袖或代表。</li></ul><p>在韦伯看来，某一支配形式有着其特定的权威类型和合法性基础，与其他合法性基础可能有着兼容的困难。例如，家长制支配形式依赖于传统权威。一旦把传统权威如长老权威放置在法理制度中（如一人一票的选举）就会产生紧张，其传统权威基础随之瓦解，家长制支配形式亦难以为继。同样的，法理权威也难以建立在墨守成规的传统基础上或者领袖的超凡禀赋上。</p><h2 id="0x01"><a class="markdownIt-Anchor" href="#0x01"></a> 0x01</h2><p><mark>中国的皇权建立在传统权威与卡理斯玛权威兼而有之的合法性基础之上</mark>，即一方面来自传统权威的祖宗之法，另一方面来自君权天授的卡理斯玛权威，体现在德治天下。在这个基础上，皇位的嫡长子继承制度，在中国帝制中是天经地义的。而官僚体制的合法性来源于自上而下的「授权」，集中表现在「向上负责制」。</p><p>民主宪政的法理权威已经成为20世纪现代国家不争的合法性基础。建国伊始，新中国的合法性几无争议地建立在这一形式之上，体现在人民代表大会和党内外的选举任命等一系列制度安排之上。但在一个经历了数千年君主官僚制、浸濡于儒教文化中的传统中国社会，法理权威并没有真正植根，所以，在国家运行的实际过程中，执政党并不是将其执政合法性基础建立在法理权威之上。而中国历史上皇权的另一个合法性基础——卡理斯玛权威——以新的形式成为执政党的实质性权力依据。</p><p><mark>当代中国国家的合法性建立在以法理权威为表、但更多地表现出卡理斯玛权威为实的混合型基础之上。</mark> 法理权威与卡理斯玛权威混合兼容的合法性基础在当代社会时常可见。但在当代中国，这一混合型基础中的两种权威未及交融熨合，法理权威根基肤浅而卡理斯玛权威强势以行，后者的意志几欲冲破前者的羁绊；这些紧张一直存在，暗流涌动，并时常以极端形式爆发而出。</p><h2 id="0x02"><a class="markdownIt-Anchor" href="#0x02"></a> 0x02</h2><p>卡理斯玛权威的核心是，领袖以其超凡禀赋而得到追随者的拥戴和服从；而领袖则通过不断地创造「奇迹」来显示其超凡禀赋，以延续和强化这一合法性基础。</p><p>艾森斯塔德指出，在卡理斯玛权威体系中，追随者的角色意义重大。正是追随者对这一社会秩序的接受和追求，对超凡能力的期待和认同，提供了卡理斯玛权威的基础。换言之，卡理斯玛权威的有效性来自各层官员以及民众对这一权威的认可和服从。<mark>一旦卡理斯玛权威建立，在领袖与追随者之间关系中，领袖不是体现或表达民意，而是指出追随者的义务和责任；</mark> 官僚体制则是按照卡理斯玛权威的意图和指令行事的一个组织机器。卡理斯玛权威需要不断的「奇迹」和各种神秘化仪式来维系和强化人们对君王的超凡禀赋的认同。</p><p>卡理斯玛权威有着内在的不稳定性和延续的困难，因此可能会经历一个「常规化」的过程，即将超凡禀赋领袖的个人魅力转而一直到稳定的组织设施上，使得这些组织设施具有卡理斯玛权威的秉性，涂上「神圣化」的色彩。</p><p>在当代中国，执政党正是卡理斯玛权威常规化的具体体现。从象征意义上来说，执政党与卡理斯玛超凡禀性如出一辙；执政党被赋予了无可替代的内生的领导能力、纠错能力、更新能力。而执政党的有效组织、严密纪律、统领全局的能力为卡理斯玛权威提供了稳定的组织基础。</p><p>正是执政党的卡理斯玛权威为专断权力提供了合法性基础。既然执政党有着超凡禀性的卡理斯玛权威，那么它在领导民族大业、驾驭常规权力、动员资源、顶层设计、统筹安排诸方面则义不容辞，可以在很大程度上替代和排斥现代社会中法理权威的出现。如此，它具有专断权力的合法性基础，在必要情势下叫停常规权力，或者将常规权力的运行状态切换到变速器的不同挡位。我们不难看到，在这里卡理斯玛权威的延续不再是与传统合法性交融铸造，而是建立在现代组织制度之上。</p><p>卡理斯玛权威的常规化不仅需要稳定的组织基础，而且需要建立在社会中心价值之上。<mark>如果放任意识形态「自由化」或多元化，就会对隐含着卡理斯玛权威的组织制度产生疑问，削弱或挑战其权威性。</mark></p><h2 id="0x03"><a class="markdownIt-Anchor" href="#0x03"></a> 0x03</h2><p>在当代中国的国家支配形式中，国家与民众的密切关联是卡理斯玛权威的合法性基础，是执政党行使权力的合法性诉求基础。官僚体制对这一合法性诉求，从两个方面提供了有力的支持：</p><p>其一是组织上实现意识形态一统化和话语垄断权。卡理斯玛权威建立在追随者对其超凡禀赋的信仰之上；不难理解，<mark>任何挑战卡理斯玛权威的话语都会弱化甚至瓦解其合法性基础，因此话语垄断权是维系卡理斯玛权威的关键所在。</mark> 建国以后，国家逐步通过官僚体制介入、控制以至垄断意识形态相关的领域，有效地杜绝了质疑或挑战卡理斯玛权威的潜在可能性，如此制度安排可以说是这一支配形式的逻辑结果。</p><p>其二是通过官僚体制将民众组织起来，以稳定的组织形式来保证民众与卡理斯玛领袖的密切关系。在这里，组织纪律成为卡理斯玛权威的重要手段。在中国，这一组织形式达到了历史上前所未有的程度，从城市到农村社会的各个领域和角落都被高度组织起来了。革命教化的向下渗透与组织起来的社会相得益彰，成为执政党的日常工作环节。各级党务部门和管理机构有着特设的宣传部门、政治工作部门，其职责即是通过一系列的组织起来的政治活动，如动员、讲用、交流、政治教育、整党整风等等，将一般民众通过工作单位、居住组织引入到政治教化过程中。简言之，政治教化不再如帝国时代那样是寓于日常生活中的仪式象征和道德约束，而是建立在一个严密组织的官僚体制基础之上。</p><p><mark>这并不是说，执政党及其领袖的所作所为总是在理性地、有意识地构建其卡理斯玛权威。</mark> 在实际运行中，这些做法更可能反映了执政党及其领袖在推行其政策、实现其抱负时尝试不同策略的试错过程，从而存优去劣的结果。有心种花也罢，无意插柳也罢，随着国家治理深度和广度的延伸，中国官僚组织的规模和复杂性在当代都有了史无前例的扩展，其特定的内在机制、行为方式以空前未有的程度充斥于社会各个角落。</p><p><mark>国家治理的诸多机制大多是在用「官僚机器以实施其意图又不得不『治』官僚体制偏离其意图」这一矛盾中产生的。</mark></p><p>在当代中国的国家建设过程中，执政党领袖试图有针对性地解决这些矛盾紧张。<mark>其中一个做法是试图将执政党与实际运行中的官僚体制加以区分，将执政党抽象化、卡理斯玛化，因此与后者出现的诸多问题区别开来。</mark> 毛泽东在批评官僚体制问题的许多场合中，时常首先强调执政党的伟大光荣正确，然后提出这些官僚体制问题违背了党的路线方针，需要通过整党整风乃至各种政治运动来解决。这些做法虽然奏效一时，但无法真正解决这一制度上的紧张。随着官僚体制在社会各个领域角落的延伸，它在民众日常生活中几近无所不在、无时不在，其弊病也为人们切身感受到。既然卡理斯玛权威建立在其追随者民众的信念之上，官僚体制作为国家执政工具，其组织失败不可避免地会引起人们对体制中最高权威的质疑，因此动摇卡理斯玛支配形式的合法性基础。</p><h2 id="0x04"><a class="markdownIt-Anchor" href="#0x04"></a> 0x04</h2><p>在中国融入世界的开放时代，执政党及其领袖的政绩也在不同社会的比较之下经受着经常性的竞争压力，卡理斯玛权威难以维系。尤其是随着中国社会本身的多元化发展，卡理斯玛权威的两个制度设施即高度一统的观念制度和严密的组织制度在改革开放时代都有了极大削弱，卡理斯玛权威所依赖的领袖与追随者之间的认同、服从的纽带已经难以为继。执政党也在努力寻找新的合法性基础，从「党和国家领导人」的任期制，到强调法治、建立健全规章制度等一系列举措来看，这是一个从卡理斯玛权威转向法理权威的过程。</p><p>但是，历史的途径依赖力量是强大的。已有的组织的、利益的、观念的制度力量仍然试图补苴罅漏，修复旧的框架，因此许多做法表现出重新加强卡理斯玛权威的努力，例如强化在意识形态领域中的管控，强化政治教化方面的一系列努力等。改革开放时期执政党的拨乱反正得到民众支持，经济起飞的政绩表现、民众生活水平的极大提高，这一切也引导着执政党沿着卡理斯玛权威的轨迹走下去，<mark>通过经济发展的「奇迹」来重建其合法性基础。</mark> 在短时期内无法构建新的合法性基础的困难中，维系和强化卡理斯玛权威的努力似乎成为执政党不得已的抉择，但又是最为得心应手的应对策略。</p><p>但近年来，卡理斯玛权威无可奈何地日渐式微，体现在一次次试图整治官僚体制的努力与失败中，以及针对官僚权力的整治力不从心的无奈境地。如此，近年来的国家建设出现了一个危险倾向，即官僚权力在其约束条件缺失的情况下急剧扩张。</p><p>但是，中国毕竟进入了21世纪。社会不可抑制地向多元方向发展起来，与力图统领和规制社会的官僚体制不可避免地发生了磕磕碰碰，甚至激烈冲突。在这个过程中，民众再次凸显出来，<mark>但今天的民众不再以卡理斯玛权威的追随者角色出现，而是公民权利、法律面前人人平等的基础之上发出声音，挑战着卡理斯玛权威及其官僚体制的合法性基础，推动着执政党由表及里走向法理权威。</mark> 近年来，各种社会矛盾，如社会不平等、民众与官僚体制冲突随着经济发展而显露出来，以国家政策和官僚体制为主体的资源分配机制成为人们的关注焦点，引发了对国家支配形式和官僚体制权力的种种质疑和抗争。可以说，今天卡理斯玛权威已经不足以提供稳定的合法性辩护，国家治理的合法性基础成为亟须回答的问题。</p><blockquote><p>本文摘录自<a href="https://book.douban.com/subject/26901114/" target="_blank" rel="noopener">中国国家治理的制度逻辑 (豆瓣)</a></p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Charismatic authority：又称魅力型权威 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;马克斯·韦伯认为任何权力都不能持久地建立在强制或暴力基础之上，而必须具有合法性基础。在这个意义上权威即是建立在合法性基础之上的权力。从这一思路出发，韦伯抽象出三个理想化权威类型：传统权威、卡理斯玛权威&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#f
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>竞争、缓存与事务</title>
    <link href="https://leay.net/2022/05/28/concurrency/"/>
    <id>https://leay.net/2022/05/28/concurrency/</id>
    <published>2022-05-27T16:00:00.000Z</published>
    <updated>2022-09-02T18:40:22.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源竞争"><a class="markdownIt-Anchor" href="#资源竞争"></a> 资源竞争</h2><p>比方说打印机同一时刻只能被一个应用程序调用，这便是进程层面的资源竞争；我们说「进程是资源分配的最小单位；线程是 CPU 调度的最小单位。」在同一进程的多线程环境下，便有可能发生线程层面的资源竞争；同理，在多机环境下也有主机间竞争资源的情况。</p><p>拿使用打印机这个场景来说，倘若同时有两个进程操作打印机，一定会导致打印出来的东西一团糟。= =！对这类情况来说，要实现资源的安全使用，必须保证同一时刻只有一个角色使用资源。要达到这一点可以从角色和资源两方面来考虑：</p><ol><li>将角色们（比如多线程）并发占用资源的行为转为串行操作：比方说有考试系统在面临大量考生涌入这个场景，为不同考生按批次设置数分钟进入考试界面的延迟。</li><li>对资源进行加锁，标识它已被占用，无法再被使用。</li></ol><p>比方说具体到 Java 在 JDK 层面的锁实现 <code>ReentrantLock.java</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，当一个线程尝试获取锁时，会先判断当前资源的状态是否为 0（未使用），是的话将之设为 1（已使用），这时别的线程就没法使用这个资源啦；否则说明该资源已被别的资源占用，这个线程就暂时没法使用该资源啰。</p><p>对于集群来说，利用 Redis 为多机环境实现锁，原理和上面一致，一个简单的伪代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(SETNX key value)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SETNX</code> 的意思是「SET if not exists」，命令在指定的 key 不存在时，为 key 设置一个 value 值，若成功返回 1；若失败返回 0。</p><p>Redis 提供的 <code>SETNX</code> 与 <code>ReentrantLock.java</code> 中的 <code>compareAndSetState()</code> 效果一样：先判断能不能设置值，能的话就设置值并返回成功，否则返回失败。对应到业务逻辑就是 <mark>先判断锁是否已被占用，若没占用就加锁并返回成功，否则返回失败。</mark> 同时，这两个命令都是内部实现的原子操作——判断、设置是两个动作，为了避免这两个动作中间被别的角色插足产生问题，就必须保证命令是一个原子操作。</p><p>多机环境对资源的竞争可以从两方面入手做限制。一是具体到真正影响资源的层面。比方说多台机器竞争的是同一个数据库里的数据，可以在数据库层面使用锁来防止资源竞争导致的问题；二是在多台机器的上层再做一层抽象，引入一个统一的资源调度——比方说在多机之上利用 Redis 设置分布式锁来管理多机环境的资源竞争。</p><p>在更上层做抽象可以减轻下层的压力。比方说有两个删除同一资源的操作同时走两台服务器去执行——显然这两个操作其实只用执行一个，我们越早确认这一点就能越早放弃其中一个以避免它再去服务器执行一遍，浪费资源。</p><h2 id="锁的优化及好多概念"><a class="markdownIt-Anchor" href="#锁的优化及好多概念"></a> 锁的优化及好多概念</h2><p>「使用资源」这个说法太宽泛了，比方说 A 在读一个资源时 B 也来读其实不会有啥安全问题，若因 A 在读一个资源就将该资源上锁，其它的 B、C……就都得等着 A 释放资源，反倒降低了效率。</p><p>因此有必要对「使用资源」的情况一一进行分析，并针对不同的情况使用不同的策略以提高效率。</p><p>比方说从「读资源」「修改（写）资源」分析，可以有如下概念：</p><ul><li>乐观锁/悲观锁<ul><li>我们乐观地假定每次访问资源都只是「读」操作，因此允许同一时刻有多个角色使用（读）资源</li><li>我们悲观地假定每次访问资源都是「写」操作，因此同一时刻只允许一个角色使用（写）资源</li></ul></li><li>独享锁/共享锁<ul><li>同一时刻只能有一个角色使用资源</li><li>同一时刻允许多个角色使用资源</li></ul></li><li>互斥锁/读写锁<ul><li>独享锁/共享锁是一种广义的说法，互斥锁/读写锁是其具体实现。</li></ul></li></ul><p>上面聊这些概念时都假定了<strong>同一时刻会有多个角色访问资源</strong>的情形，要是我们再乐观点，考虑「一个资源会有被并发访问的可能但多数时间都不会到这一步」等特殊情况，就可以再为此做一些优化，减少对锁的维护所消耗的资源。</p><p>比方说 Java 里有四种锁状态：</p><ul><li>无锁状态：还没有线程占用资源。</li><li>偏向锁状态：只有一个线程占用资源。</li><li>轻量级锁状态：假定锁占用时间很短，不会产生资源竞争。</li><li>重量级锁状态：锁占用资源的时间较长，产生资源竞争，线程被阻塞。</li></ul><p>在轻量级锁与重量级锁之间还会有一个「自旋」的操作。它假定「产生了资源竞争，但锁占用时间不长」，那么线程便尝试通过自旋来获取资源，以优化线程切换造成的资源浪费。</p><p>我们又怎么判断「应该自旋多久呢？」虽然通过自旋可以减少线程阻塞导致线程切换使用的资源，但要是锁持有时间确实比较长，那么自旋操作反倒因为线程的空等待浪费了资源。针对这一点，JVM 假定不同线程持有同一个对象锁的时间基本相当，会根据上一次自旋的时间与结果来调整下一次自旋的时间。</p><ul><li>自旋锁</li></ul><p>另一方面，我们应该使用什么策略来分配资源呢？比方说我们可以使用「先来后到」的资源分配方式，但对于不同的场景，这种策略不一定总是高效的。从这个角度考虑，可以引出：</p><ul><li>公平锁/非公平锁</li></ul><p>一方面将资源有所侧重地分配可能在业务流程上更高效；另一方面，比如一个线程来竞争资源时，如果直接将资源分配给它，就能减少从另外一堆线程中将某个线程从阻塞唤醒的线程切换动作，节约系统资源。</p><h2 id="引入缓存"><a class="markdownIt-Anchor" href="#引入缓存"></a> 引入缓存</h2><p>在计算机里，我们「使用资源」时往往操作的是这个资源的缓存。例如操作系统层面有主存和缓存；JVM 层面有主存和工作内存；应用层面会为数据库引入 Redis 等做缓存，数据库自己可能也带有缓存机制。</p><p>例如 JVM 在 JMM（Java 内存模型）定义所有的变量都存放在主存（物理内存），每个线程都有自己的工作内存（高速缓存）。倘若一个线程修改了自己缓存中的值，那么就可能涉及到两点：</p><ol><li>缓存中的值与主存同步。</li><li>某线程的缓存里的值与其它线程的缓存中的值同步。</li></ol><p>为此，JMM 规定了三点：</p><ul><li><p>线程解锁前，必须把共享变量的值刷新回主内存；</p></li><li><p>线程加锁前，必须读取主内存的最新值到自己的工作内存；</p></li><li><p>加锁解锁同一把锁。</p></li></ul><p>类似的，在操作系统层面通过内存屏障来保证数据一致：</p><ul><li>缓存有更新，立马同步回主存；</li><li>主存有更新，立马使缓存失效。</li></ul><p>比方说应用层面可能有些对数据的一致性要求没那么高的场景，可以在缓存使用定期从主存更新数据的策略。若有要求呢？可查阅 2PC、3PC 等一致性协议及算法。</p><hr><p>拿 JDK 层面来说，多线程对 int 类型的值做计算是不安全的，因为会有多个线程同时对各自缓存中的值做计算，再同步回主存的情况。由于它们各自独立计算再往主存同步，相互之间没有交流，导致部分线程的计算操作没有被继承，而是被覆盖丢失了。</p><p>为了避免这种问题，需要将每个线程的每次计算操作当作一个「原子操作」来进行，即每次线程切换时，能保证我这次计算已经作为一个原子操作执行完了（更新到主存）。</p><p>对于这类问题，操作系统是通过「总线锁定」来解决的。在操作系统层面，数据间通过总线来通信，一个 CPU 想要改变某个共享数据时，会通过总线通知其它 CPU 不可使用该数据。</p><p>而在 JDK 层面引入了原子操作类，通过 CAS（compare and swap）保证做计算操作的原子性。简单来说，每个线程尝试对缓存中的数据进行操作前，会以自旋的方式不断拿一个预期值（当然是此时主存里的值）去和缓存值做比较，如果两者不一致，就说明主存里的值已经被别的线程改动过了，当前线程应该等待缓存被更新为最新的值再去做计算。若一致，则说明现在缓存里的值可能是最新的值，当前线程可以对数据进行操作。这个比较并计算的操作（CAS）是利用指令层面的特性实现的，能保证原子性。不过 CAS 也有一些细节上的问题：</p><ul><li>ABA 问题：假如一个值从 A 变为 B 又改回 A，对于当前线程来说看起来没有变化，实际上改变过两次。<ul><li>这个问题对于不需要记录变化次数的场景来说其实没有影响，如需要考虑，可以用版本号机制——每次变化都更新版本号。当值相同且版本号一致时，我们才判断这个值没有变化过。</li></ul></li><li>一直自旋，时间长开销大。<ul><li>设置超时时间、超时次数。</li></ul></li><li>只能保证一个共享变量的原子操作。<ul><li>CAS 利用指令层面的特性，若涉及多个变量，就无法保证多个变量之间不会被别的操作插入，因此无法保证多个共享变量的原子操作。若涉及多个变量可以通过加锁解决。</li><li>但也有<a href="https://www.wikiwand.com/en/Double_compare-and-swap" target="_blank" rel="noopener">特殊的 CAS 算法</a>尝试对两个共享变量使用 CAS 保证原子性。</li></ul></li></ul><h2 id="数据库里的事务"><a class="markdownIt-Anchor" href="#数据库里的事务"></a> 数据库里的事务</h2><p>事务也需要保证原子性——一个事务内的操作要么全部执行成功要么全部失败。在并发编程的概念中，原子性包含「原子操作」与「操作互不可见」两点，而事务中的原子性只有「事务中的操作作为原子操作」一点，「操作互不可见」单独指「隔离性」——一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><p>和上面的场景类似，事务也会有并发的情况呀——由于事务的粒度比较大，拿来分析资源竞争产生的问题就比较清晰。</p><p>事务可能会产生以下四种并发一致性问题：</p><ul><li>读脏数据：事务 A 读到了事务 B 尚未提交的数据后，事务 B 又回滚了。因此事务 A 读到了 B 造成的脏数据。</li><li>丢失修改：事务 A 和 事务 B 同时对数据进行修改，A 修改后 B 接着修改，A 提交后 B 接着提交。B 提交后导致 A 的修改没生效，于是 A 丢失了修改。</li><li>不可重复读：事务 A 两次读取某些数据期间事务 B 修改了其中的数据，导致事务 A 这两次读取到的数据不一致。（数据不一致）</li><li>幻读：事务 A 两次读取同一区域的数据期间事务 B 新增或删除了这区间的数据，导致两次读取到同一区域的数据数目不一致。（数目不一致）</li></ul><p>事务和其它资源竞争的场景一样，倘若只有读的操作，就不会出现冲突了……针对并发不一致问题，数据库会有四种不同程度的隔离级别：</p><ul><li>未提交读（READ UNCOMMITTED）：一个事务能读到其它事务尚未提交的修改。<mark>最低级别，啥都不能保证。</mark></li><li>提交读（READ COMMITTED）：一个事务只能读取到其它事务已提交的修改。<mark>可避免脏读。</mark></li><li>可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。<mark>可避免脏读、不可重复读。</mark></li><li>串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。<mark>可避免脏读、不可重复读、幻读。</mark></li></ul><p>可见「串行化」是以「并发转串行」的思路来解决并发竞争资源的问题的——实际上是通过加锁机制实现。四种隔离级别中也只有「串行化」是从根本上解决「事务竞争资源」这一问题。但「串行化」对性能损耗较大——针对一些要求低点或者我们能确保不会出问题的的场景，就可以选择其它的隔离级别。</p><p>具体到某种事务隔离级别是怎样通过锁来实现的可以参见 MySQL 的 MVCC 机制。</p><p>与其它多机环境一样，事务也会有分布式事务的场景。比方说跨行转账业务——银行 A 扣钱，银行 B 存钱。这也必须作为一个原子操作进行。关于分布式事务如何保证 ACID 可见 XA、Saga 等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;资源竞争&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#资源竞争&quot;&gt;&lt;/a&gt; 资源竞争&lt;/h2&gt;&lt;p&gt;比方说打印机同一时刻只能被一个应用程序调用，这便是进程层面的资源竞争；我们说「进程是资源分配的最小单位；线程是 CPU 调度的最小单位
      
    
    </summary>
    
    
      <category term="学习折腾" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/"/>
    
      <category term="自己浅见" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/%E8%87%AA%E5%B7%B1%E6%B5%85%E8%A7%81/"/>
    
    
      <category term="Java" scheme="https://leay.net/tags/Java/"/>
    
  </entry>
  
</feed>
