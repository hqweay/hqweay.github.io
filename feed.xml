<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>养恐龙</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://leay.net/"/>
  <updated>2022-06-14T15:49:23.987Z</updated>
  <id>https://leay.net/</id>
  
  <author>
    <name>hqweay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>让我们再尝试下好好说话</title>
    <link href="https://leay.net/2022/06/14/steelmanning/"/>
    <id>https://leay.net/2022/06/14/steelmanning/</id>
    <published>2022-06-13T16:00:00.000Z</published>
    <updated>2022-06-14T15:49:23.987Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.wikiwand.com/zh-hans/%E7%A8%BB%E8%8D%89%E4%BA%BA%E8%AB%96%E8%AD%89" target="_blank" rel="noopener">稻草人论证</a> 是一种通过曲解对方的论点，并针对曲解后的论点（替身稻草人）攻击，再宣称已推翻对方论点的论证形式。与之相对的，<a href="https://www.wikiwand.com/en/Straw_man#Steelmanning" target="_blank" rel="noopener">钢铁侠策略</a> 是一种通过确定对方论点，甚至帮助对方构建出最恰当的论点，然后对此进行辩论的方式。前阵子聊过 <a href="/2022/03/19/how-to-discuss/">类似的想法</a>，没想到还有个专门的说法。</p><p>我觉得这对试图从对话中有所收获，而不是享受攻击的快感的人来说，确实是值得使用的讨论技巧。</p><p>比方说面对一篇文章，应当以最理性的方式<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>去理解作者的表达——想象这个常见的场景，读者批评作者「你怎么不说什么什么」——当遇到作者似乎漏掉什么时，最好合理地考虑「这点是不是对论证文章的核心观点无益？」而不是「你太无知了，这也不知道。」或者「你忽略了那些，所以这篇文章是在以偏概全。」</p><p>最近读到 <a href="https://mp.weixin.qq.com/s/tuXmRMRxH7rFBYGyEITbsw" target="_blank" rel="noopener">Not All Men 为什么这么糟糕？</a>，文章批评了在讨论女权主义议题时插嘴「不是所有男人」的对话者，因为这是在破坏对话。</p><p>我觉得文章写得很好，但它似乎并没有对「不是所有」这个说法做出回应，而是通过描绘一幅「这样会如何」的糟糕图景反过来说「不是所有」这种说法是不好的。因此文章读起来不是那么客气，而且似乎对它的标题本身避重就轻。</p><p>我觉得，严谨的用词在实践上并不是必须的——比方说讨论女权问题时表达者可以给所有涉及「男性」的地方加一个「有些」——「有些男性」，但同理倾听的人也可以去理解表达者，将词汇脑补一个限定词使之更「严谨」呀。从挑错的角度来讲，我们拥有无数种方式指责表达者「不够中立」或「挑拨情绪」——对于想要好好讨论的人来说，这样的批评并没有贡献任何价值；而对于那些真正激进地宣扬「所有男人都该死」的内容来说，也不会因为批评而把口号改成「部分男人该死」——后者搞不好在义正严辞地反驳后还会加重「果然对男人就是不能讲道理、就是应该拨乱反正」的信念。</p><p>这当然有可能是一种偷懒——我讨厌一些创作者用「我只写给部分人」的借口掩饰自己实则不肯求证或另有考虑，讨厌把它当作铠甲听不得半点批评，讨厌自己也常常以艰深文浅陋。但这种心虚的模糊很容易和求知所犯的错误区分开来的——通过你从文章读出的真诚。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.wikiwand.com/en/Principle_of_charity" target="_blank" rel="noopener">慈善原则</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.wikiwand.com/zh-hans/%E7%A8%BB%E8%8D%89%E4%BA%BA%E8%AB%96%E8%AD%89&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;稻草人论证&lt;/a&gt; 是一种通过曲解
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="杂文" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="杂文" scheme="https://leay.net/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>软件系统的复杂度</title>
    <link href="https://leay.net/2022/06/13/complexity/"/>
    <id>https://leay.net/2022/06/13/complexity/</id>
    <published>2022-06-12T16:00:00.000Z</published>
    <updated>2022-06-13T15:35:52.525Z</updated>
    
    <content type="html"><![CDATA[<p>《A Philosophy of Software Design》的作者通过衡量软件系统是否容易被理解和修改来定义「复杂度」。</p><p>「复杂」表现出三个症状：</p><ul><li><p><strong>Change amplification</strong>：一个看似简单的修改实际上却需要修改很多代码。</p><ul><li><p>比如说多个网页有着同样的背景色，却各自单独维护，因此想要改变多个页面的背景色就得同时改动多个页面的代码——我们很容易想到，可以通过维护一个共享变量来控制各个页面的背景色，这样只需要修改一次就能满足要求了。</p></li><li><blockquote><p>一堆字段重合度非常高的列表展示页，全都各自有一个页面。一次需求让将列表中部分字段脱敏展示，于是只能一个页面一个页面地修改。</p></blockquote></li></ul></li><li><p><strong>Cognitive load</strong>：认知负荷，指开发人员需要了解多少前提才能完成任务。更高的认知负荷意味着开发人员必须花费更多时间来学习所需的信息，并且存在更大的错误风险。</p><ul><li>比方说要修改一个 API 的返回值、业务逻辑，那至少得掌握这个 API 被多少地方调用。比方说同事 A 炫技写了个短却复杂的代码——看代码量是够精简的，可其它同事甚至他自己在后面修改时，都很难搞清楚这些代码在干嘛。假如函数名语义不明确、有副作用……都会增加开发人员认知负担。</li></ul></li><li><p><strong>Unknown unknowns</strong>：开发人员不知道自己不知道，他不知道必须修改哪些代码或者掌握哪些信息才能完成任务。</p><ul><li><p>比方说网站使用一个共享变量控制字体颜色，但一些网页却单独控制自己的背景色。因此对于大部分网页来说，更改字体颜色后没啥问题，但对于一些有着特殊背景色的网页，则有可能出现原来的背景色对于现在的字体来说太亮，导致网页没有可读性的情况。而即使开发人员意识到这样的问题，也不清楚具体涉及哪些特殊页面，因此又需要花大量时间排查。</p></li><li><blockquote><p>有次在项目 A 新增了一个异常码，而这类异常码会被另一个好久没动过的项目 B 用到，B 使用时需要将 A 的异常码转换成 B 的格式——没人意识到这点，结果问题在需求后期才暴露出来。</p></blockquote></li></ul></li></ul><p>造成「复杂」的两个原因：</p><ul><li><p>依赖关系：依赖不可避免，但应该尽量简单明了。</p></li><li><p>模糊：重要的信息不够明显就会变得模糊。比如变量名取的太通用了，完全搞不清楚它会被用于啥；（想象一个叫 <code>data</code> 的变量名）一个变量的文档没有说明单位，因此我们只能扫描代码看看使用这个变量的地方是怎么用的；模糊性经常和依赖关系相关，即依赖关系没那么明显——比如新增的错误码需要维护一个字符串，这个字符串对开发人员来说就没那么明显。</p><ul><li><blockquote><p>遇到过接口文档的一个金额字段的单位是「元」，而建表用的「分」。</p></blockquote></li></ul></li></ul><blockquote><p>书中举的例子都太他妈真实了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;《A Philosophy of Software Design》的作者通过衡量软件系统是否容易被理解和修改来定义「复杂度」。&lt;/p&gt;&lt;p&gt;「复杂」表现出三个症状：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Change amplification&lt;/strong&gt;：一个
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>数组、越界及遍历</title>
    <link href="https://leay.net/2022/06/01/index-out-of-bounds/"/>
    <id>https://leay.net/2022/06/01/index-out-of-bounds/</id>
    <published>2022-05-31T16:00:00.000Z</published>
    <updated>2022-06-01T16:07:11.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组越界检查"><a class="markdownIt-Anchor" href="#数组越界检查"></a> 数组越界检查</h2><p>在 C 语言里遇到数组访问越界时，虽然编译可能会有警告，但代码是能成功运行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>因为一个数组在计算机内表现为一段内存地址，当我们尝试越界访问数组时，实际上是在尝试越过那一段内存地址去访问别的内存地址上的数据——倘若我们尝试访问的地址是合法的，且又没做任何控制，那么自然也能访问到数据。</p><p>而在 Java 中类似逻辑的代码虽然能正常编译，但当 Java 虚拟机执行 class 文件时却会抛错 <code>ArrayIndexOutOfBoundsException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr[<span class="number">5</span>]);</span><br><span class="line">System.out.println(arr[-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>很容易想到是不是 JVM 层面做了什么控制——确实如此，比方说 hotspot 虚拟机里相关的控制实现如下：</p><ul><li><a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/interpreter/bytecodeInterpreter.cpp" target="_blank" rel="noopener">jdk8/jdk8/hotspot: 87ee5ee27509 src/share/vm/interpreter/bytecodeInterpreter.cpp</a></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hotspot\src\share\vm\interpreter\bytecodeInterpreter.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_INTRO(arrayOff)                                                  \</span></span><br><span class="line">      arrayOop arrObj = (arrayOop)STACK_OBJECT(arrayOff);                      \</span><br><span class="line">      jint     index  = STACK_INT(arrayOff + <span class="number">1</span>);                               \</span><br><span class="line">      <span class="keyword">char</span> message[jintAsStringSize];                                          \</span><br><span class="line">      CHECK_NULL(arrObj);                                                      \</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)index &gt;= (<span class="keyword">uint32_t</span>)arrObj-&gt;length()) &#123;                     \</span><br><span class="line">          <span class="built_in">sprintf</span>(message, <span class="string">"%d"</span>, index);                                       \</span><br><span class="line">          VM_JAVA_ERROR(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), \</span><br><span class="line">                        message);                                              \</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>hotspot 将会判断访问数组的索引是否超过了数组的长度限制，若是，则抛出数组访问越界异常。</p><p>注意索引被转换成了 <code>uint32_t</code> 类型（无符号类型），因此当索引为负数时会被转换为相应的无符号类型数。Java 中数组的大小和 int 的取值范围有关，int 占 32 byte 大小，取值范围是 <code>-2147483648 至 2147483647</code>，因此负数的取值范围为 <code>-2147483648 至 -1</code>，相应的补码（用补码表示负数）的取值范围是 <code>2147483648 至 4294967295</code>。</p><p>显然为负数的索引在这会被判断超过限制从而抛出异常。</p><p>但比如说在遍历一个大号数组的场景下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">999999</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然数组的访问索引 <code>i</code> 的取值显然不会越界，那其实没必要每次访问数组的值时都进行一次越界检查——实际上 JVM 判断出这种情况后会进行「数组边界检查消除」的优化来减少性能浪费。</p><h2 id="jdk-层面的越界检查"><a class="markdownIt-Anchor" href="#jdk-层面的越界检查"></a> JDK 层面的越界检查</h2><p>Java 是在 JVM 层面对数组是否越界进行判断的，而对于集合对象来说，则在 JDK 层面进行越界检查。比方说 <code>LinkedList</code> 的 <code>get()</code> 中的越界检查实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index);</span><br><span class="line">  <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历数组"><a class="markdownIt-Anchor" href="#遍历数组"></a> 遍历数组</h2><p>就简来说，Java 中有三种 for 循环用于遍历集合对象。（下面的 two 和 three 一般统称为 foreach 或 增强 for 循环，我做下区分方便讨论。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one 经典 for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size; i++)</span><br><span class="line">  System.out.println(arr.get(i))</span><br><span class="line"><span class="comment">// two 增强 for</span></span><br><span class="line"><span class="keyword">for</span>(T a : arr)</span><br><span class="line">  System.out.println(a)</span><br><span class="line"><span class="comment">// three foreach</span></span><br><span class="line">arr.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>比方说 <code>Iterable.java</code> 提供的 <code>foreach()</code> 的实现简单好懂，其实是在 JDK 层面利用 Lambda 表达式做参数，封装了增强 for：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java/lang/Iterable.java</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;  </span><br><span class="line">    Objects.requireNonNull(action);  </span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;  </span><br><span class="line">        action.accept(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强 for 仍然是个语法糖，<mark>遍历集合时</mark>底层使用 Iterator，<mark>遍历数组</mark>时底层用的普通 for：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span> <span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; var1)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(var1);</span><br><span class="line">    Iterator var2 = <span class="keyword">this</span>. iterator():</span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext())&#123;</span><br><span class="line">        Object var3 = var2.next;</span><br><span class="line">        var1.accept(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;;  </span><br><span class="line">String[] var2 = str;  </span><br><span class="line"><span class="keyword">int</span> var3 = str.length;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;  </span><br><span class="line">  String s = var2[var4];  </span><br><span class="line">  System.out.println(s);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fail-fast"><a class="markdownIt-Anchor" href="#fail-fast"></a> fail-fast</h2><p>fail-fast 顾名思义，快速失败——让它崩溃！发现问题，马上让它暴露出来。</p><p>比如下面就是一个 fail-fast 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">null</span> == name) <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">  <span class="comment">//……s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Java 集合中 fail-fast 体现为：当遍历集合对象时，若集合对象同时被进行了「结构性更改」的操作，则会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>啥是结构性更改呢？</p><blockquote><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html#modCount" target="_blank" rel="noopener">ListIterator (Java Platform SE 7 )</a></p><p>Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.</p></blockquote><p>我觉得后面这段有点暧昧「或者以其它方式扰乱数组，以至于正在进行的迭代可能会产生错误的结果」，什么其它方式？以及，什么错误的结果？</p><p>我理解结构性更改的方式有两种：</p><ul><li>集合对象中元素数目的变动（如 add()、remove()、addAll()、clear()……）</li><li>集合对象内部结构的更改<ul><li>这个要具体到集合对象的实现，比如 HashMap 的 rehash()、ArrayList 的 replaceAll()。</li><li>比方说 HashMap 的 set() 就不算结构性更改，为啥 ArrayList 的 replaceAll() 就算结构性更改？</li></ul></li></ul><p>至于错误的结果，按我的理解：</p><ul><li>比如对于 HashMap 来说，倘若遍历的途中进行了 rehash() 操作，显然遍历的结果会出问题。</li><li>比如对于 List 来说，倘若遍历的途中添加或删除了一些元素，会导致「也许部分添加的元素被遍历出来了而部分元素未能遍历」等数据不一致的情况。</li></ul><p>Java 实现 fail-fast 的方式很清晰——集合对象内提供了一个 <code>modCount</code> 元素保存对象进行结构性更改的次数。这样在遍历之前，会取一个 <code>modCount</code> 的快照作为期望值 <code>expectedModCount</code>，每次访问时会判断这个期望值与当前的 <code>modCount</code> 是否一致。倘若不一致，这说明遍历期间有人捣蛋，则抛出<code>ConcurrentModificationException</code> 异常。</p><p>比方说 <code>ArrayList.java</code> 的 <code>foreach()</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">  Objects.requireNonNull(action);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">  <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++)</span><br><span class="line">    action.accept(elementAt(es, i));</span><br><span class="line">  <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要在-foreach-循环里进行元素的-addremove-操作"><a class="markdownIt-Anchor" href="#不要在-foreach-循环里进行元素的-addremove-操作"></a> 不要在 foreach 循环里进行元素的 add/remove 操作</h2><ul><li>见 <a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">Alibaba Java Coding Guidelines</a></li></ul><p>这里的 foreach 循环如果指前文提到的第三种遍历集合对象的元素，那就简单了。比方说上面 <code>ArrayList.java</code> 的 <code>foreach()</code> 实现，很明显会抛出 <code>ConcurrentModificationException</code> 异常——「为什么不要？」因为会抛异常嘛。</p><p>但倘若指前文提到的第二种遍历方式，即增强型 for 循环——则没这么显然了。因为增强型 for 循环实际上是 Iterator 的封装，因此需要到 Iterator 的实现里去看看会发生什么事。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(<span class="string">"one"</span>);</span><br><span class="line">    arrayList.add(<span class="string">"two"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : arrayList)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">"one"</span>.equals(s))&#123;</span><br><span class="line">        System.out.println(arrayList.remove(s));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(<span class="string">"one"</span>);</span><br><span class="line">    arrayList.add(<span class="string">"two"</span>);</span><br><span class="line">    <span class="keyword">for</span>(String s : arrayList)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">"two"</span>.equals(s))&#123;</span><br><span class="line">        System.out.println(arrayList.remove(s));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line">ArrayList var1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    var1.add(<span class="string">"one"</span>);</span><br><span class="line">    var1.add(<span class="string">"two"</span>);</span><br><span class="line">    Iterator var2 = var1.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">      String var3 = (String)var2.next(); <span class="comment">// next() 会检查集合对象是否进行结构性更改</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"one"</span>.equals(var3)) &#123;</span><br><span class="line">        System.out.println(var1.remove(var3));<span class="comment">// remove() 会记录为一次结构性更改</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Iterator 实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">int</span> i = cursor;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">  cursor = i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比反编译后的 three 及其实现来看例子 one 和 two 的执行情况：</p><ul><li>例子 one 能正常执行：对例子 one 来说，第一次遍历便进行 remove()，此时游标 cursor 为 1，size 为 1，因此尝试第二次遍历时因为 hasNext() 为 false，跳出遍历。</li><li>而例子 two 会抛异常：对于例子 two 来说，第二次遍历进行 remove()，此时游标 cursor 为 2，size 为 1，因此尝试第二次遍历时因为 hasNext() 为 true，尝试进行第三次遍历，此时进入 next() 方法便抛出 <code>ConcurrentModificationException</code> 异常。</li></ul><p>看样子仍然很危险呐——因此还是不要在 foreach 循环里进行元素的 add/remove 操作吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组越界检查&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数组越界检查&quot;&gt;&lt;/a&gt; 数组越界检查&lt;/h2&gt;&lt;p&gt;在 C 语言里遇到数组访问越界时，虽然编译可能会有警告，但代码是能成功运行的：&lt;/p&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
    
      <category term="学习折腾" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/"/>
    
      <category term="自己浅见" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/%E8%87%AA%E5%B7%B1%E6%B5%85%E8%A7%81/"/>
    
    
      <category term="Java" scheme="https://leay.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>竞争、缓存与事务</title>
    <link href="https://leay.net/2022/05/28/concurrency/"/>
    <id>https://leay.net/2022/05/28/concurrency/</id>
    <published>2022-05-27T16:00:00.000Z</published>
    <updated>2022-05-28T09:06:11.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源竞争"><a class="markdownIt-Anchor" href="#资源竞争"></a> 资源竞争</h2><p>比方说打印机同一时刻只能被一个应用程序调用，这便是进程层面的资源竞争；我们说「进程是资源分配的最小单位；线程是 CPU 调度的最小单位。」在同一进程的多线程环境下，便有可能发生线程层面的资源竞争；同理，在多机环境下也有主机间竞争资源的情况。</p><p>拿使用打印机这个场景来说，倘若同时有两个进程操作打印机，一定会导致打印出来的东西一团糟。= =！对这类情况来说，要实现资源的安全使用，必须保证同一时刻只有一个角色使用资源。要达到这一点可以从角色和资源两方面来考虑：</p><ol><li>将角色们（比如多线程）并发占用资源的行为转为串行操作：比方说有考试系统在面临大量考生涌入这个场景，为不同考生按批次设置数分钟进入考试界面的延迟。</li><li>对资源进行加锁，标识它已被占用，无法再被使用。</li></ol><p>比方说具体到 Java 在 JDK 层面的锁实现 <code>ReentrantLock.java</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，当一个线程尝试获取锁时，会先判断当前资源的状态是否为 0（未使用），是的话将之设为 1（已使用），这时别的线程就没法使用这个资源啦；否则说明该资源已被别的资源占用，这个线程就暂时没法使用该资源啰。</p><p>对于集群来说，利用 Redis 为多机环境实现锁，原理和上面一致，一个简单的伪代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(SETNX key value)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SETNX</code> 的意思是「SET if not exists」，命令在指定的 key 不存在时，为 key 设置一个 value 值，若成功返回 1；若失败返回 0。</p><p>Redis 提供的 <code>SETNX</code> 与 <code>ReentrantLock.java</code> 中的 <code>compareAndSetState()</code> 效果一样：先判断能不能设置值，能的话就设置值并返回成功，否则返回失败。对应到业务逻辑就是 <mark>先判断锁是否已被占用，若没占用就加锁并返回成功，否则返回失败。</mark> 同时，这两个命令都是内部实现的原子操作——判断、设置是两个动作，为了避免这两个动作中间被别的角色插足产生问题，就必须保证命令是一个原子操作。</p><p>多机环境对资源的竞争可以从两方面入手做限制。一是具体到真正影响资源的层面。比方说多台机器竞争的是同一个数据库里的数据，可以在数据库层面使用锁来防止资源竞争导致的问题；二是在多台机器的上层再做一层抽象，引入一个统一的资源调度——比方说在多机之上利用 Redis 设置分布式锁来管理多机环境的资源竞争。</p><p>在更上层做抽象可以减轻下层的压力。比方说有两个删除同一资源的操作同时走两台服务器去执行——显然这两个操作其实只用执行一个，我们越早确认这一点就能越早放弃其中一个以避免它再去服务器执行一遍，浪费资源。</p><h2 id="锁的优化及好多概念"><a class="markdownIt-Anchor" href="#锁的优化及好多概念"></a> 锁的优化及好多概念</h2><p>「使用资源」这个说法太宽泛了，比方说 A 在读一个资源时 B 也来读其实不会有啥安全问题，若因 A 在读一个资源就将该资源上锁，其它的 B、C……就都得等着 A 释放资源，反倒降低了效率。</p><p>因此有必要对「使用资源」的情况一一进行分析，并针对不同的情况使用不同的策略以提高效率。</p><p>比方说从「读资源」「修改（写）资源」分析，可以有如下概念：</p><ul><li>乐观锁/悲观锁<ul><li>我们乐观地假定每次访问资源都只是「读」操作，因此允许同一时刻有多个角色使用（读）资源</li><li>我们悲观地假定每次访问资源都是「写」操作，因此同一时刻只允许一个角色使用（写）资源</li></ul></li><li>独享锁/共享锁<ul><li>同一时刻只能有一个角色使用资源</li><li>同一时刻允许多个角色使用资源</li></ul></li><li>互斥锁/读写锁<ul><li>独享锁/共享锁是一种广义的说法，互斥锁/读写锁是其具体实现。</li></ul></li></ul><p>上面聊这些概念时都假定了<strong>同一时刻会有多个角色访问资源</strong>的情形，要是我们再乐观点，考虑「一个资源会有被并发访问的可能但多数时间都不会到这一步」等特殊情况，就可以再为此做一些优化，减少对锁的维护所消耗的资源。</p><p>比方说 Java 里有四种锁状态：</p><ul><li>无锁状态：还没有线程占用资源。</li><li>偏向锁状态：只有一个线程占用资源。</li><li>轻量级锁状态：假定锁占用时间很短，不会产生资源竞争。</li><li>重量级锁状态：锁占用资源的时间较长，产生资源竞争，线程被阻塞。</li></ul><p>在轻量级锁与重量级锁之间还会有一个「自旋」的操作。它假定「产生了资源竞争，但锁占用时间不长」，那么线程便尝试通过自旋来获取资源，以优化线程切换造成的资源浪费。</p><p>我们又怎么判断「应该自旋多久呢？」虽然通过自旋可以减少线程阻塞导致线程切换使用的资源，但要是锁持有时间确实比较长，那么自旋操作反倒因为线程的空等待浪费了资源。针对这一点，JVM 假定不同线程持有同一个对象锁的时间基本相当，会根据上一次自旋的时间与结果来调整下一次自旋的时间。</p><ul><li>自旋锁</li></ul><p>另一方面，我们应该使用什么策略来分配资源呢？比方说我们可以使用「先来后到」的资源分配方式，但对于不同的场景，这种策略不一定总是高效的。从这个角度考虑，可以引出：</p><ul><li>公平锁/非公平锁</li></ul><p>一方面将资源有所侧重地分配可能在业务流程上更高效；另一方面，比如一个线程来竞争资源时，如果直接将资源分配给它，就能减少从另外一堆线程中将某个线程从阻塞唤醒的线程切换动作，节约系统资源。</p><h2 id="引入缓存"><a class="markdownIt-Anchor" href="#引入缓存"></a> 引入缓存</h2><p>在计算机里，我们「使用资源」时往往操作的是这个资源的缓存。例如操作系统层面有主存和缓存；JVM 层面有主存和工作内存；应用层面会为数据库引入 Redis 等做缓存，数据库自己可能也带有缓存机制。</p><p>例如 JVM 在 JMM（Java 内存模型）定义所有的变量都存放在主存（物理内存），每个线程都有自己的工作内存（高速缓存）。倘若一个线程修改了自己缓存中的值，那么就可能涉及到两点：</p><ol><li>缓存中的值与主存同步。</li><li>某线程的缓存里的值与其它线程的缓存中的值同步。</li></ol><p>为此，JMM 规定了三点：</p><ul><li><p>线程解锁前，必须把共享变量的值刷新回主内存；</p></li><li><p>线程加锁前，必须读取主内存的最新值到自己的工作内存；</p></li><li><p>加锁解锁同一把锁。</p></li></ul><p>类似的，在操作系统层面通过内存屏障来保证数据一致：</p><ul><li>缓存有更新，立马同步回主存；</li><li>主存有更新，立马使缓存失效。</li></ul><p>比方说应用层面可能有些对数据的一致性要求没那么高的场景，可以在缓存使用定期从主存更新数据的策略。若有要求呢？可查阅 2PC、3PC 等一致性协议及算法。</p><hr><p>拿 JDK 层面来说，多线程对 int 类型的值做计算是不安全的，因为会有多个线程同时对各自缓存中的值做计算，再同步回主存的情况。由于它们各自独立计算再往主存同步，相互之间没有交流，导致部分线程的计算操作没有被继承，而是被覆盖丢失了。</p><p>为了避免这种问题，需要将每个线程的每次计算操作当作一个「原子操作」来进行，即每次线程切换时，能保证我这次计算已经作为一个原子操作执行完了（更新到主存）。</p><p>对于这类问题，操作系统是通过「总线锁定」来解决的。在操作系统层面，数据间通过总线来通信，一个 CPU 想要改变某个共享数据时，会通过总线通知其它 CPU 不可使用该数据。</p><p>而在 JDK 层面引入了原子操作类，通过 CAS（compare and swap）保证做计算操作的原子性。简单来说，每个线程尝试对缓存中的数据进行操作前，会以自旋的方式不断拿一个预期值（当然是此时主存里的值）去和缓存值做比较，如果两者不一致，就说明主存里的值已经被别的线程改动过了，当前线程应该等待缓存被更新为最新的值再去做计算。若一致，则说明现在缓存里的值可能是最新的值，当前线程可以对数据进行操作。这个比较并计算的操作（CAS）是利用指令层面的特性实现的，能保证原子性。不过 CAS 也有一些细节上的问题：</p><ul><li>ABA 问题：假如一个值从 A 变为 B 又改回 A，对于当前线程来说看起来没有变化，实际上改变过两次。<ul><li>这个问题对于不需要记录变化次数的场景来说其实没有影响，如需要考虑，可以用版本号机制——每次变化都更新版本号。当值相同且版本号一致时，我们才判断这个值没有变化过。</li></ul></li><li>一直自旋，时间长开销大。<ul><li>设置超时时间、超时次数。</li></ul></li><li>只能保证一个共享变量的原子操作。<ul><li>CAS 利用指令层面的特性，若涉及多个变量，就无法保证多个变量之间不会被别的操作插入，因此无法保证多个共享变量的原子操作。若涉及多个变量可以通过加锁解决。</li><li>但也有<a href="https://www.wikiwand.com/en/Double_compare-and-swap" target="_blank" rel="noopener">特殊的 CAS 算法</a>尝试对两个共享变量使用 CAS 保证原子性。</li></ul></li></ul><h2 id="数据库里的事务"><a class="markdownIt-Anchor" href="#数据库里的事务"></a> 数据库里的事务</h2><p>事务也需要保证原子性——一个事务内的操作要么全部执行成功要么全部失败。在并发编程的概念中，原子性包含「原子操作」与「操作互不可见」两点，而事务中的原子性只有「事务中的操作作为原子操作」一点，「操作互不可见」单独指「隔离性」——一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><p>和上面的场景类似，事务也会有并发的情况呀——由于事务的粒度比较大，拿来分析资源竞争产生的问题就比较清晰。</p><p>事务可能会产生以下四种并发一致性问题：</p><ul><li>读脏数据：事务 A 读到了事务 B 尚未提交的数据后，事务 B 又回滚了。因此事务 A 读到了 B 造成的脏数据。</li><li>丢失修改：事务 A 和 事务 B 同时对数据进行修改，A 修改后 B 接着修改，A 提交后 B 接着提交。B 提交后导致 A 的修改没生效，于是 A 丢失了修改。</li><li>不可重复读：事务 A 两次读取某些数据期间事务 B 修改了其中的数据，导致事务 A 这两次读取到的数据不一致。（数据不一致）</li><li>幻读：事务 A 两次读取同一区域的数据期间事务 B 新增或删除了这区间的数据，导致两次读取到同一区域的数据数目不一致。（数目不一致）</li></ul><p>事务和其它资源竞争的场景一样，倘若只有读的操作，就不会出现冲突了……针对并发不一致问题，数据库会有四种不同程度的隔离级别：</p><ul><li>未提交读（READ UNCOMMITTED）：一个事务能读到其它事务尚未提交的修改。<mark>最低级别，啥都不能保证。</mark></li><li>提交读（READ COMMITTED）：一个事务只能读取到其它事务已提交的修改。<mark>可避免脏读。</mark></li><li>可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一数据的结果是一样的。<mark>可避免脏读、不可重复读。</mark></li><li>串行化（SERIALIZABLE）：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。<mark>可避免脏读、不可重复读、幻读。</mark></li></ul><p>可见「串行化」是以「并发转串行」的思路来解决并发竞争资源的问题的——实际上是通过加锁机制实现。四种隔离级别中也只有「串行化」是从根本上解决「事务竞争资源」这一问题。但「串行化」对性能损耗较大——针对一些要求低点或者我们能确保不会出问题的的场景，就可以选择其它的隔离级别。</p><p>具体到某种事务隔离级别是怎样通过锁来实现的可以参见 MySQL 的 MVCC 机制。</p><p>与其它多机环境一样，事务也会有分布式事务的场景。比方说跨行转账业务——银行 A 扣钱，银行 B 存钱。这也必须作为一个原子操作进行。关于分布式事务如何保证 ACID 可见 XA、Saga 等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;资源竞争&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#资源竞争&quot;&gt;&lt;/a&gt; 资源竞争&lt;/h2&gt;&lt;p&gt;比方说打印机同一时刻只能被一个应用程序调用，这便是进程层面的资源竞争；我们说「进程是资源分配的最小单位；线程是 CPU 调度的最小单位
      
    
    </summary>
    
    
      <category term="学习折腾" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/"/>
    
      <category term="自己浅见" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/%E8%87%AA%E5%B7%B1%E6%B5%85%E8%A7%81/"/>
    
    
      <category term="Java" scheme="https://leay.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>除了英雄我们还可以期待什么</title>
    <link href="https://leay.net/2022/05/28/hero/"/>
    <id>https://leay.net/2022/05/28/hero/</id>
    <published>2022-05-27T16:00:00.000Z</published>
    <updated>2022-05-28T11:14:36.145Z</updated>
    
    <content type="html"><![CDATA[<p>马克斯·韦伯认为任何权力都不能持久地建立在强制或暴力基础之上，而必须具有合法性基础。在这个意义上权威即是建立在合法性基础之上的权力。从这一思路出发，韦伯抽象出三个理想化权威类型：传统权威、卡理斯玛权威<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>和法理权威。</p><ul><li>传统权威：顾名思义，是从历史上传承下来的习俗传统中得到合法性，如传统社会中的长老权威从沿袭已久的文化传统中得以维系和延续。</li><li>卡理斯玛权威：以领袖的超凡禀赋来获取追随者的认同拥戴，从而得到其合法性基础，这在社会运动如农民起义和各类集体行为中尤为突出。</li><li>法理权威：依据民众所认可接受的公正程序而得到合法性基础，例如经过选举程序产生的领袖或代表。</li></ul><p>在韦伯看来，某一支配形式有着其特定的权威类型和合法性基础，与其他合法性基础可能有着兼容的困难。例如，家长制支配形式依赖于传统权威。一旦把传统权威如长老权威放置在法理制度中（如一人一票的选举）就会产生紧张，其传统权威基础随之瓦解，家长制支配形式亦难以为继。同样的，法理权威也难以建立在墨守成规的传统基础上或者领袖的超凡禀赋上。</p><h2 id="0x01"><a class="markdownIt-Anchor" href="#0x01"></a> 0x01</h2><p><mark>中国的皇权建立在传统权威与卡理斯玛权威兼而有之的合法性基础之上</mark>，即一方面来自传统权威的祖宗之法，另一方面来自君权天授的卡理斯玛权威，体现在德治天下。在这个基础上，皇位的嫡长子继承制度，在中国帝制中是天经地义的。而官僚体制的合法性来源于自上而下的「授权」，集中表现在「向上负责制」。</p><p>民主宪政的法理权威已经成为20世纪现代国家不争的合法性基础。建国伊始，新中国的合法性几无争议地建立在这一形式之上，体现在人民代表大会和党内外的选举任命等一系列制度安排之上。但在一个经历了数千年君主官僚制、浸濡于儒教文化中的传统中国社会，法理权威并没有真正植根，所以，在国家运行的实际过程中，执政党并不是将其执政合法性基础建立在法理权威之上。而中国历史上皇权的另一个合法性基础——卡理斯玛权威——以新的形式成为执政党的实质性权力依据。</p><p><mark>当代中国国家的合法性建立在以法理权威为表、但更多地表现出卡理斯玛权威为实的混合型基础之上。</mark> 法理权威与卡理斯玛权威混合兼容的合法性基础在当代社会时常可见。但在当代中国，这一混合型基础中的两种权威未及交融熨合，法理权威根基肤浅而卡理斯玛权威强势以行，后者的意志几欲冲破前者的羁绊；这些紧张一直存在，暗流涌动，并时常以极端形式爆发而出。</p><h2 id="0x02"><a class="markdownIt-Anchor" href="#0x02"></a> 0x02</h2><p>卡理斯玛权威的核心是，领袖以其超凡禀赋而得到追随者的拥戴和服从；而领袖则通过不断地创造「奇迹」来显示其超凡禀赋，以延续和强化这一合法性基础。</p><p>艾森斯塔德指出，在卡理斯玛权威体系中，追随者的角色意义重大。正是追随者对这一社会秩序的接受和追求，对超凡能力的期待和认同，提供了卡理斯玛权威的基础。换言之，卡理斯玛权威的有效性来自各层官员以及民众对这一权威的认可和服从。<mark>一旦卡理斯玛权威建立，在领袖与追随者之间关系中，领袖不是体现或表达民意，而是指出追随者的义务和责任；</mark> 官僚体制则是按照卡理斯玛权威的意图和指令行事的一个组织机器。卡理斯玛权威需要不断的「奇迹」和各种神秘化仪式来维系和强化人们对君王的超凡禀赋的认同。</p><p>卡理斯玛权威有着内在的不稳定性和延续的困难，因此可能会经历一个「常规化」的过程，即将超凡禀赋领袖的个人魅力转而一直到稳定的组织设施上，使得这些组织设施具有卡理斯玛权威的秉性，涂上「神圣化」的色彩。</p><p>在当代中国，执政党正是卡理斯玛权威常规化的具体体现。从象征意义上来说，执政党与卡理斯玛超凡禀性如出一辙；执政党被赋予了无可替代的内生的领导能力、纠错能力、更新能力。而执政党的有效组织、严密纪律、统领全局的能力为卡理斯玛权威提供了稳定的组织基础。</p><p>正是执政党的卡理斯玛权威为专断权力提供了合法性基础。既然执政党有着超凡禀性的卡理斯玛权威，那么它在领导民族大业、驾驭常规权力、动员资源、顶层设计、统筹安排诸方面则义不容辞，可以在很大程度上替代和排斥现代社会中法理权威的出现。如此，它具有专断权力的合法性基础，在必要情势下叫停常规权力，或者将常规权力的运行状态切换到变速器的不同挡位。我们不难看到，在这里卡理斯玛权威的延续不再是与传统合法性交融铸造，而是建立在现代组织制度之上。</p><p>卡理斯玛权威的常规化不仅需要稳定的组织基础，而且需要建立在社会中心价值之上。<mark>如果放任意识形态「自由化」或多元化，就会对隐含着卡理斯玛权威的组织制度产生疑问，削弱或挑战其权威性。</mark></p><h2 id="0x03"><a class="markdownIt-Anchor" href="#0x03"></a> 0x03</h2><p>在当代中国的国家支配形式中，国家与民众的密切关联是卡理斯玛权威的合法性基础，是执政党行使权力的合法性诉求基础。官僚体制对这一合法性诉求，从两个方面提供了有力的支持：</p><p>其一是组织上实现意识形态一统化和话语垄断权。卡理斯玛权威建立在追随者对其超凡禀赋的信仰之上；不难理解，<mark>任何挑战卡理斯玛权威的话语都会弱化甚至瓦解其合法性基础，因此话语垄断权是维系卡理斯玛权威的关键所在。</mark> 建国以后，国家逐步通过官僚体制介入、控制以至垄断意识形态相关的领域，有效地杜绝了质疑或挑战卡理斯玛权威的潜在可能性，如此制度安排可以说是这一支配形式的逻辑结果。</p><p>其二是通过官僚体制将民众组织起来，以稳定的组织形式来保证民众与卡理斯玛领袖的密切关系。在这里，组织纪律成为卡理斯玛权威的重要手段。在中国，这一组织形式达到了历史上前所未有的程度，从城市到农村社会的各个领域和角落都被高度组织起来了。革命教化的向下渗透与组织起来的社会相得益彰，成为执政党的日常工作环节。各级党务部门和管理机构有着特设的宣传部门、政治工作部门，其职责即是通过一系列的组织起来的政治活动，如动员、讲用、交流、政治教育、整党整风等等，将一般民众通过工作单位、居住组织引入到政治教化过程中。简言之，政治教化不再如帝国时代那样是寓于日常生活中的仪式象征和道德约束，而是建立在一个严密组织的官僚体制基础之上。</p><p><mark>这并不是说，执政党及其领袖的所作所为总是在理性地、有意识地构建其卡理斯玛权威。</mark> 在实际运行中，这些做法更可能反映了执政党及其领袖在推行其政策、实现其抱负时尝试不同策略的试错过程，从而存优去劣的结果。有心种花也罢，无意插柳也罢，随着国家治理深度和广度的延伸，中国官僚组织的规模和复杂性在当代都有了史无前例的扩展，其特定的内在机制、行为方式以空前未有的程度充斥于社会各个角落。</p><p><mark>国家治理的诸多机制大多是在用「官僚机器以实施其意图又不得不『治』官僚体制偏离其意图」这一矛盾中产生的。</mark></p><p>在当代中国的国家建设过程中，执政党领袖试图有针对性地解决这些矛盾紧张。<mark>其中一个做法是试图将执政党与实际运行中的官僚体制加以区分，将执政党抽象化、卡理斯玛化，因此与后者出现的诸多问题区别开来。</mark> 毛泽东在批评官僚体制问题的许多场合中，时常首先强调执政党的伟大光荣正确，然后提出这些官僚体制问题违背了党的路线方针，需要通过整党整风乃至各种政治运动来解决。这些做法虽然奏效一时，但无法真正解决这一制度上的紧张。随着官僚体制在社会各个领域角落的延伸，它在民众日常生活中几近无所不在、无时不在，其弊病也为人们切身感受到。既然卡理斯玛权威建立在其追随者民众的信念之上，官僚体制作为国家执政工具，其组织失败不可避免地会引起人们对体制中最高权威的质疑，因此动摇卡理斯玛支配形式的合法性基础。</p><h2 id="0x04"><a class="markdownIt-Anchor" href="#0x04"></a> 0x04</h2><p>在中国融入世界的开放时代，执政党及其领袖的政绩也在不同社会的比较之下经受着经常性的竞争压力，卡理斯玛权威难以维系。尤其是随着中国社会本身的多元化发展，卡理斯玛权威的两个制度设施即高度一统的观念制度和严密的组织制度在改革开放时代都有了极大削弱，卡理斯玛权威所依赖的领袖与追随者之间的认同、服从的纽带已经难以为继。执政党也在努力寻找新的合法性基础，从「党和国家领导人」的任期制，到强调法治、建立健全规章制度等一系列举措来看，这是一个从卡理斯玛权威转向法理权威的过程。</p><p>但是，历史的途径依赖力量是强大的。已有的组织的、利益的、观念的制度力量仍然试图补苴罅漏，修复旧的框架，因此许多做法表现出重新加强卡理斯玛权威的努力，例如强化在意识形态领域中的管控，强化政治教化方面的一系列努力等。改革开放时期执政党的拨乱反正得到民众支持，经济起飞的政绩表现、民众生活水平的极大提高，这一切也引导着执政党沿着卡理斯玛权威的轨迹走下去，<mark>通过经济发展的「奇迹」来重建其合法性基础。</mark> 在短时期内无法构建新的合法性基础的困难中，维系和强化卡理斯玛权威的努力似乎成为执政党不得已的抉择，但又是最为得心应手的应对策略。</p><p>但近年来，卡理斯玛权威无可奈何地日渐式微，体现在一次次试图整治官僚体制的努力与失败中，以及针对官僚权力的整治力不从心的无奈境地。如此，近年来的国家建设出现了一个危险倾向，即官僚权力在其约束条件缺失的情况下急剧扩张。</p><p>但是，中国毕竟进入了21世纪。社会不可抑制地向多元方向发展起来，与力图统领和规制社会的官僚体制不可避免地发生了磕磕碰碰，甚至激烈冲突。在这个过程中，民众再次凸显出来，<mark>但今天的民众不再以卡理斯玛权威的追随者角色出现，而是公民权利、法律面前人人平等的基础之上发出声音，挑战着卡理斯玛权威及其官僚体制的合法性基础，推动着执政党由表及里走向法理权威。</mark> 近年来，各种社会矛盾，如社会不平等、民众与官僚体制冲突随着经济发展而显露出来，以国家政策和官僚体制为主体的资源分配机制成为人们的关注焦点，引发了对国家支配形式和官僚体制权力的种种质疑和抗争。可以说，今天卡理斯玛权威已经不足以提供稳定的合法性辩护，国家治理的合法性基础成为亟须回答的问题。</p><blockquote><p>本文摘录自<a href="https://book.douban.com/subject/26901114/" target="_blank" rel="noopener">中国国家治理的制度逻辑 (豆瓣)</a></p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Charismatic authority：又称魅力型权威 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;马克斯·韦伯认为任何权力都不能持久地建立在强制或暴力基础之上，而必须具有合法性基础。在这个意义上权威即是建立在合法性基础之上的权力。从这一思路出发，韦伯抽象出三个理想化权威类型：传统权威、卡理斯玛权威&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#f
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>代码过长，编译失败</title>
    <link href="https://leay.net/2022/05/27/code-too-large/"/>
    <id>https://leay.net/2022/05/27/code-too-large/</id>
    <published>2022-05-26T16:00:00.000Z</published>
    <updated>2022-06-01T15:43:31.014Z</updated>
    
    <content type="html"><![CDATA[<p>今天当发版工具人时遇到编译报错「代码过长（code too large）」，把这段说明发到工作群里，瞬间听到周围一片爽朗的笑声……</p><p>挺让我惊讶，原来 Java 里的方法大小是有限制的——编译后的字节码大小不能超过 64kb。</p><p>JVM 规范 <a href="https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-4.html#jvms-4.7.3" target="_blank" rel="noopener">Chapter 4. The class File Format</a> 在 <code>class</code> 结构的 <code>method_info</code> （方法信息）里定义了一个 u1 类型<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的数组来保存该 Java 方法编译后的数据，这个数组的大小由一个 u2 类型<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>的变量确定。</p><p>1 个 u2 类型的值占 2 byte， 2 byte 就是 16 bit（位），16 bit 所能表示的最大值是 2 的 16 次方——65536。因此一个 u2 类型的变量的最大值就是 65536，所以这个数组也就最多只能保存 65536 byte，即 64kb 的数据。（1 kb = 1024 byte）</p><p>这个错误虽然可以在编译期间暴露，但 JVM 并不能保证它加载的 class 文件都是满足要求的，因此在加载 class 文件的验证阶段，还会对该数组的长度进行检查。</p><hr><p>除了普通方法外，构造方法、初始化代码块也受到此限制。</p><p>初始化代码块为什么也受到此限制呢？<mark>我猜测初始化代码块在 JVM 层面还是当作方法来使用的。</mark></p><p>同时，如果一个 Java 类里有多个初始化代码块，虽然每个代码块里的代码没有超出此限制，但当它们之和超过该限制时，也会编译报错「代码过长」。<mark>我猜测多个初始化代码块在 JVM 层面会被优化成一个方法来使用。</mark></p><blockquote><p>代码块保存在 JVM 的哪块区域？</p></blockquote><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOne</span></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"哈哈哈哈哈"</span>);</span><br><span class="line">    <span class="comment">// repeat 4000 times</span></span><br><span class="line">    System.out.println(<span class="string">"哈哈哈哈哈"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"哈哈哈哈哈"</span>);</span><br><span class="line">    <span class="comment">// repeat 4000 times</span></span><br><span class="line">    System.out.println(<span class="string">"哈哈哈哈哈"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"哈哈哈哈哈"</span>);</span><br><span class="line">    <span class="comment">// repeat 4000 times</span></span><br><span class="line">    System.out.println(<span class="string">"哈哈哈哈哈"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更有趣的是，Java 中数组的大小理论上与 <a href="https://stackoverflow.com/questions/31382531/why-i-cant-create-an-array-with-large-size" target="_blank" rel="noopener">int 的取值范围相关</a>，但实际上可能在初始化数组时，还未达到最大容量便报错「代码过长」：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">    <span class="string">"哈哈哈含安安安安哈哈哈含安安安安哈哈哈含安安安安哈哈哈含安安安安"</span>,</span><br><span class="line">    <span class="comment">//…… repeat 10000 times</span></span><br><span class="line">    <span class="string">"哈哈哈含安安安安哈哈哈含安安安安哈哈哈含安安安安哈哈哈含安安安安"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>类似的，<a href="https://docs.oracle.com/javase/specs/jvms/se13/html/jvms-4.html#jvms-4.11" target="_blank" rel="noopener">JVM 规范</a> 还介绍了「类或接口可以声明的字段数量限制在 65535」「方法参数的数量限制为 255」等情况。：）</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>1 byte （字节）的无符号数 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>2 byte 的无符号数 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天当发版工具人时遇到编译报错「代码过长（code too large）」，把这段说明发到工作群里，瞬间听到周围一片爽朗的笑声……&lt;/p&gt;&lt;p&gt;挺让我惊讶，原来 Java 里的方法大小是有限制的——编译后的字节码大小不能超过 64kb。&lt;/p&gt;&lt;p&gt;JVM 规范 &lt;a hr
      
    
    </summary>
    
    
      <category term="学习折腾" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/"/>
    
      <category term="自己浅见" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/%E8%87%AA%E5%B7%B1%E6%B5%85%E8%A7%81/"/>
    
    
      <category term="Java" scheme="https://leay.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用邮箱别名</title>
    <link href="https://leay.net/2022/05/09/mail/"/>
    <id>https://leay.net/2022/05/09/mail/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-05-11T11:41:47.581Z</updated>
    
    <content type="html"><![CDATA[<p>在使用邮箱订阅信息这个场景，有些人会新建邮箱账号或用上一堆规则来整理收到的邮件。比如<a href="https://rizime.substack.com/p/one2?s=r" target="_blank" rel="noopener">newsletter 邮件过滤规则 - Λ-Reading</a> 尝试了许多关键字后，建议使用「unsubscribe」（取消订阅）来过滤整理 Newsletter。</p><p>不如使用邮箱的别名来完成。</p><p>Gmail 支持用加号创建别名。对于 <a href="mailto:A@gmail.com">A@gmail.com</a> 来说，A+a@gmail.com、A+b@gmail.com 都是合法的别名，发送到后两个地址的邮件都能被 <a href="mailto:A@gmail.com">A@gmail.com</a> 接收。</p><p>可以用 <a href="mailto:A+sub@gmail.com">A+sub@gmail.com</a> 来订阅信息，然后新建规则将发送到该地址的邮件移动到某文件夹。同理用 <a href="mailto:A+reg@gmail.com">A+reg@gmail.com</a> 作为注册专用邮箱等。</p><p>其它邮箱服务也大多支持别名，域名邮箱也可以自定义许多邮箱地址，但似乎都没 Gmail 「+任意字符」方便。但对于「订阅信息」「注册账号」两个场景，手动建两个别名邮箱也还好，一劳永逸嘛。</p><p>部分网站不能正常识别带「+」号的邮箱，大概是用正则表达式校验邮箱格式了。<a href="https://www.yuque.com/jwenjian/reading-list/pk5md5" target="_blank" rel="noopener">在这</a>看到一篇建议不要使用正则表达式校验邮箱的<a href="https://davidcelis.micro.blog/2012/09/06/stop-validating-email.html" target="_blank" rel="noopener">博文</a>——因为即使把正则写得非常复杂也很难满足所有情况。不如向这个邮箱发封确认激活的邮件。</p><p>下次遇到正常邮箱校验不通过的情况，可用该理由向网站管理员布道。😂</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用邮箱订阅信息这个场景，有些人会新建邮箱账号或用上一堆规则来整理收到的邮件。比如&lt;a href=&quot;https://rizime.substack.com/p/one2?s=r&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;newsletter 邮件过滤
      
    
    </summary>
    
    
      <category term="学习折腾" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/"/>
    
      <category term="配置与操作" scheme="https://leay.net/categories/%E5%AD%A6%E4%B9%A0%E6%8A%98%E8%85%BE/%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="配置与操作" scheme="https://leay.net/tags/%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>哲学病</title>
    <link href="https://leay.net/2022/05/02/problem/"/>
    <id>https://leay.net/2022/05/02/problem/</id>
    <published>2022-05-01T16:00:00.000Z</published>
    <updated>2022-05-02T07:04:45.850Z</updated>
    
    <content type="html"><![CDATA[<p>看看这幅漫画<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>：</p><p><img data-src="/2022/05/02/problem/20100926.gif" alt="2010-09-26"></p><p>陀思妥耶夫斯基在《地下室手记》描述了相似的困境：</p><p>一个人要开始行动，就必须事先完全心安理得。实干家们之所以充满干劲，是因为他们把最近的、次要的原因当成了初始原因，于是也就比别人更快且更容易地相信自己已经找到了无可争辩的基石。</p><p>但「任何一个初始原因都会立刻连带地拽出另一个起始更早的原因，如此等等，以至无穷。」</p><p>譬如说「报复」，一个人之所以要报复，是因为他认为这样做是对的。也就是说他找到了初始的原因，找到了「行动的基石」。因此他各方面都十分心安理得，报复起来也就十分从容，因为他坚信自己在做一件光明磊落而又十分正义的事情。</p><p>而你——却从中找不到任何正义性。因此说要给「报复」找一个行动的基石，那只能是「愤恨」。愤恨足以战胜一切，包括所有的疑虑。但一个人若是连愤恨都没有，那又该如何？</p><p>逻辑上讲，原因之下总还有个导致这原因的原因——愤恨由于意识到这一规律而消散了。你找不到理由，找不到罪人。</p><p>于是你不妨盲目地听从自己感情的驱使，不要发议论，不要寻找初始的原因。驱散自己的意识，去恨或者去爱——只要不是无所事事地坐着就行。或者你知道这只是明明白白地自欺欺人，于是什么事也不做。</p><p>《罪与罚》可以说是这个困境的扩写，我们能看到<a href="/2022/03/23/ufer/">主角是如何尝试从这条没有尽头的困惑中解脱出来的</a>，他迫切地想要投入到生活里去，却因此杀了人，犯了错，且没法「明明白白地自欺欺人」。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.smbc-comics.com/comic/2010-09-27" target="_blank" rel="noopener">https://www.smbc-comics.com/comic/2010-09-27</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看看这幅漫画&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;/2022/05/02/problem/20100926.gif&quot; alt=&quot;201
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>心理学作为科学</title>
    <link href="https://leay.net/2022/05/02/psychology/"/>
    <id>https://leay.net/2022/05/02/psychology/</id>
    <published>2022-05-01T16:00:00.000Z</published>
    <updated>2022-05-02T10:28:15.045Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://journal.psych.ac.cn/xlxb/CN/10.3724/SP.J.1041.2019.01068" target="_blank" rel="noopener">“操作性定义”和“证伪标准”不足以为心理学奠基</a></li></ul><p>广义上讲，一切系统的知识均可称之为科学；狭义上的科学，则专指西方文艺复兴以来出现的探索知识的一种方式，这种方式是以物理学为榜样，是由伽利略所开创的、牛顿奠基的科学原理和方法体系，强调以实验和数学的方法观察总结客观事物发展过程中具有普遍性的本质及联系。通常对科学的理解，是指狭义的科学。事实上，<mark>并非所有的知识都能称为科学。</mark> 因为在“知识”、“学科”和“科学”之间，存在包含关系。具体而言，系统的知识构成学科(discipline)，学科包括人文学科(humanities)、自然科学(science)、社会科学(social science)等。在各学科中，只有那些以实证精神为核心，基于近代自然科学构建的探究方法所形成的学科体系，才能被称为科学，因此，科学主要指实证意义上的自然科学和社会科学。</p><p>依据狭义科学的定义，哲学、逻辑学都被排除在科学的范畴之外。</p><p>对心理学知识的科学性的划界，不能等同于对心理学与伪心理学的划界，这个划界标准不能作为判定心理学知识合法性的标准。正是从这个意义上讲，精神分析属于非科学心理学，但却不属于伪心理学。<mark>心理学作为一个独立的学科体系，它的合理结构既需要“科学”成分，也需要“非科学”成分。</mark></p><p>在心理学科内部，导致方法论误用的根本原因，在于将科学心理学的知识视为了心理学知识的全部，并用评判科学与非科学的标准，来评判所有心理学知识的“真伪”。</p><p>对心理学而言， 要走出这个困境， 首先要改变通过方法来界定学科的现状。<mark>本学科的独特价值不取决于共有的方法， 而是独特的研究对象。</mark> 人性论取向才构成心理学作为独立学科的合法前提， 而不是方法论。</p><p><mark>人性论为心理学提供了属于本学科的本体论承诺<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</mark> 要获得这个本体论承诺，心理学需要重新审视“人性”与“物性”的本质区别，才能在此基础上重新审视并设计出更加适合探究人性的方法论基础和具体的研究技术，才能让本学科在本体论承诺方面实现理论自觉，才会让心理学不会满足于对其他成熟自然科学的外在模仿，从而建构起作为独立学科的坚实基础。</p><p>至于<mark>本体论承诺从何而得</mark>，除了考察“人性”与“物性”的区别之外，借助历史上重要心理学思想家们的观点，可能为我们提供更多的启发。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>蒯因《论何物存在》 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://journal.psych.ac.cn/xlxb/CN/10.3724/SP.J.1041.2019.01068&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“操作性定义”和“证伪标准”不足以为心理学奠基&lt;/a
      
    
    </summary>
    
    
      <category term="生活志" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/"/>
    
      <category term="观与感" scheme="https://leay.net/categories/%E7%94%9F%E6%B4%BB%E5%BF%97/%E8%A7%82%E4%B8%8E%E6%84%9F/"/>
    
    
      <category term="阅读所思" scheme="https://leay.net/tags/%E9%98%85%E8%AF%BB%E6%89%80%E6%80%9D/"/>
    
  </entry>
  
</feed>
